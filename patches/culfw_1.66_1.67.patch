diff -uarN culfw-1.66/CHANGED culfw-1.67/CHANGED
--- culfw-1.66/CHANGED	2016-03-20 19:39:40.000000000 +0100
+++ culfw-1.67/CHANGED	2017-09-07 15:38:51.000000000 +0200
@@ -1,4 +1,11 @@
-Version 1.66 (2015-11-29)
+Version 1.67 (2016-11-23)
+- Hoermann Send (activated for CUL + nanoCUL)
+- RFR filter: ufKERV forwards only messages starting with one of KERV
+- Make EnoceanPI SCC compatible by hermi (Forum #60028)
+- Fix the 433 PIN-check for "non-stdard" devices.
+- Honeywell evohome first version by Colin
+
+Version 1.66 (2016-04-07)
 - CULV3/V4: add ZWave receive
 - ZWave: receive+send @ 40k, 100k
 - intertechno: modify interval
diff -uarN culfw-1.66/Devices/CUL/CUL.c culfw-1.67/Devices/CUL/CUL.c
--- culfw-1.66/Devices/CUL/CUL.c	2015-11-29 20:51:55.000000000 +0100
+++ culfw-1.67/Devices/CUL/CUL.c	2017-09-07 15:38:49.000000000 +0200
@@ -64,70 +64,82 @@
 #ifdef HAS_ZWAVE
 #include "rf_zwave.h"
 #endif
+#ifdef HAS_EVOHOME
+#include "rf_evohome.h"
+#endif
+
 
 const PROGMEM t_fntab fntab[] = {
 
+#ifdef HAS_ASKSIN
+  { 'A', asksin_func },
+#endif
   { 'B', prepare_boot },
 #ifdef HAS_MBUS
   { 'b', rf_mbus_func },
 #endif
   { 'C', ccreg },
+#ifdef HAS_RWE
+  { 'E', rwe_func },
+#endif
+  { 'e', eeprom_factory_reset },
   { 'F', fs20send },
-#ifdef HAS_INTERTECHNO
-  { 'i', it_func },
+#ifdef HAS_FASTRF
+  { 'f', fastrf_func },
 #endif
-#ifdef HAS_ASKSIN
-  { 'A', asksin_func },
+#ifdef HAS_RAWSEND
+  { 'G', rawsend },
 #endif
-#ifdef HAS_MORITZ
-  { 'Z', moritz_func },
+#ifdef HAS_HOERMANN_SEND
+  { 'h', hm_send },
 #endif
-#ifdef HAS_RFNATIVE
-  { 'N', native_func },
+#ifdef HAS_INTERTECHNO
+  { 'i', it_func },
 #endif
-#ifdef HAS_RWE
-  { 'E', rwe_func },
+#ifdef HAS_RAWSEND
+  { 'K', ks_send },
 #endif
 #ifdef HAS_KOPP_FC
   { 'k', kopp_fc_func },
 #endif
+#ifdef HAS_BELFOX
+  { 'L', send_belfox },
+#endif
+  { 'l', ledfunc },
 #ifdef HAS_RAWSEND
-  { 'G', rawsend },
   { 'M', em_send },
-  { 'K', ks_send },
-#endif
-#ifdef HAS_UNIROLL
-  { 'U', ur_send },
-#endif
-#ifdef HAS_SOMFY_RTS
-  { 'Y', somfy_rts_func },
-#endif
-  { 'R', read_eeprom },
-  { 'T', fhtsend },
-  { 'V', version },
-  { 'W', write_eeprom },
-  { 'X', set_txreport },
-
-  { 'e', eeprom_factory_reset },
-#ifdef HAS_FASTRF
-  { 'f', fastrf_func },
 #endif
 #ifdef HAS_MEMFN
   { 'm', getfreemem },
 #endif
-#ifdef HAS_BELFOX
-  { 'L', send_belfox },
+#ifdef HAS_RFNATIVE
+  { 'N', native_func },
 #endif
-  { 'l', ledfunc },
+  { 'R', read_eeprom },
+  { 'T', fhtsend },
   { 't', gettime },
+#ifdef HAS_UNIROLL
+  { 'U', ur_send },
+#endif
 #ifdef HAS_RF_ROUTER
   { 'u', rf_router_func },
 #endif
+  { 'V', version },
+#ifdef HAS_EVOHOME
+  { 'v', rf_evohome_func },
+#endif
+  { 'W', write_eeprom },
+  { 'X', set_txreport },
   { 'x', ccsetpa },
+#ifdef HAS_SOMFY_RTS
+  { 'Y', somfy_rts_func },
+#endif
+#ifdef HAS_MORITZ
+  { 'Z', moritz_func },
+#endif
 #ifdef HAS_ZWAVE
   { 'z', zwave_func },
 #endif
-
   { 0, 0 },
 };
 
@@ -226,6 +238,9 @@
 #ifdef HAS_ZWAVE
     rf_zwave_task();
 #endif
+#ifdef HAS_EVOHOME
+    rf_evohome_task();
+#endif
 
   }
 }
diff -uarN culfw-1.66/Devices/CUL/board.h culfw-1.67/Devices/CUL/board.h
--- culfw-1.66/Devices/CUL/board.h	2015-11-30 21:09:08.000000000 +0100
+++ culfw-1.67/Devices/CUL/board.h	2017-09-07 15:38:49.000000000 +0200
@@ -14,10 +14,16 @@
 #define USB_MAX_POWER	       100
 #define HAS_FHT_80b                     // PROGMEM: 1374b, RAM: 90b
 #define HAS_RF_ROUTER                   // PROGMEM: 1248b  RAM: 44b
+#define RFR_FILTER                      // PROGMEM:   90b  RAM:  4b
+#define HAS_HOERMANN
+#define HAS_HOERMANN_SEND               // PROGMEM:  220
 #define HAS_CC1101_RX_PLL_LOCK_CHECK_TASK_WAIT	// PROGMEM: 118b
 #define HAS_CC1101_PLL_LOCK_CHECK_MSG		// PROGMEM:  22b
 #define HAS_CC1101_PLL_LOCK_CHECK_MSG_SW	// PROGMEM:  22b
 
+#undef  RFR_DEBUG                       // PROGMEM:  354b  RAM: 14b
+#undef  HAS_FASTRF                      // PROGMEM:  468b  RAM:  1b
+
 #if defined(CUL_V3_ZWAVE)
 #  define CUL_V3
 #endif
@@ -27,10 +33,8 @@
 #  define HAS_FHT_TF
 #  define FHTBUF_SIZE          174      //                 RAM: 174b
 #  define RCV_BUCKETS            4      //                 RAM: 25b * bucket
-#  define RFR_DEBUG                     // PROGMEM:  354b  RAM: 14b
 #  define FULL_CC1100_PA                // PROGMEM:  108b
 #  define HAS_RAWSEND                   //
-#  define HAS_FASTRF                    // PROGMEM:  468b  RAM:  1b
 #  define HAS_ASKSIN                    // PROGMEM: 1314
 #  define HAS_ASKSIN_FUP                // PROGMEM:   78
 #  define HAS_MORITZ                    // PROGMEM: 1696
@@ -39,7 +43,6 @@
 #  define HAS_INTERTECHNO               // PROGMEM: 1352
 #  define HAS_TCM97001                  // PROGMEM:  264
 #  define HAS_UNIROLL                   // PROGMEM:   92
-#  define HAS_HOERMANN
 #  define HAS_MEMFN                     // PROGMEM:  168
 #  define HAS_SOMFY_RTS                 // PROGMEM: 1716
 #  define HAS_BELFOX                    // PROGMEM:  214
@@ -55,7 +58,6 @@
 #  define HAS_MBUS                      // PROGMEM: 2536
 #  define MBUS_NO_TX                       // PROGMEM:  962
 #  define HAS_RFNATIVE                  // PROGMEM:  580
-//#  define LACROSSE_HMS_EMU              // PROGMEM: 2206
 #  define HAS_KOPP_FC                   // PROGMEM: 3370
 #endif
 
@@ -64,6 +66,8 @@
 #  undef HAS_MBUS
 #  undef HAS_KOPP_FC
 #  undef HAS_RFNATIVE
+#  define LACROSSE_HMS_EMU              // PROGMEM: 2206
+#  define HAS_EVOHOME
 #endif
 
 
@@ -73,7 +77,7 @@
 #  define RCV_BUCKETS            2 
 #  define RFR_SHADOW                    // PROGMEM: 10b    RAM: -(TTY_BUFSIZE+3)
 #  define HAS_TX3
-#  define HAS_HOERMANN
+#  define NO_RF_DEBUG                   // squeeze out some bytes for hoermann_send
 #  undef  HAS_CC1101_RX_PLL_LOCK_CHECK_TASK_WAIT
 #endif
 
diff -uarN culfw-1.66/Devices/CUL/makefile culfw-1.67/Devices/CUL/makefile
--- culfw-1.66/Devices/CUL/makefile	2015-11-30 21:09:08.000000000 +0100
+++ culfw-1.67/Devices/CUL/makefile	2017-09-07 15:38:49.000000000 +0200
@@ -18,6 +18,7 @@
 		../../clib/rf_receive.c                              \
 		../../clib/rf_router.c                               \
 		../../clib/rf_asksin.c                               \
+                ../../clib/rf_evohome.c                              \
 		../../clib/rf_moritz.c                               \
 		../../clib/rf_rwe.c                                  \
 		../../clib/rf_native.c                               \
diff -uarN culfw-1.66/Devices/CUNO/CUNO.c culfw-1.67/Devices/CUNO/CUNO.c
--- culfw-1.66/Devices/CUNO/CUNO.c	2014-06-11 17:38:03.000000000 +0200
+++ culfw-1.67/Devices/CUNO/CUNO.c	2017-09-07 15:38:49.000000000 +0200
@@ -163,8 +163,8 @@
 
   clock_prescale_set(clock_div_1);
 
-  MCUSR &= ~(1 << WDRF);                   // Enable the watchdog
-  wdt_enable(WDTO_2S);
+//  MCUSR &= ~(1 << WDRF);                   // Enable the watchdog
+//  wdt_enable(WDTO_2S);
 
   uart_init( UART_BAUD_SELECT_DOUBLE_SPEED(UART_BAUD_RATE,F_CPU) );
 
diff -uarN culfw-1.66/Devices/CUNO/board.h culfw-1.67/Devices/CUNO/board.h
--- culfw-1.66/Devices/CUNO/board.h	2015-04-30 16:50:52.000000000 +0200
+++ culfw-1.67/Devices/CUNO/board.h	2017-09-07 15:38:49.000000000 +0200
@@ -90,8 +90,8 @@
 #define HAS_UART                1
 #define UART_BAUD_RATE          38400
 #define HAS_ETHERNET            1
-#define HAS_ETHERNET_KEEPALIVE  1
-#define ETHERNET_KEEPALIVE_TIME 30
+//#define HAS_ETHERNET_KEEPALIVE  1
+//#define ETHERNET_KEEPALIVE_TIME 30
 #define HAS_NTP                 1
 #define HAS_ONEWIRE						  10		// OneWire Device Buffer, RAM: 10 * 8 Byte
 
diff -uarN culfw-1.66/Devices/CUNO2/CUNO2.c culfw-1.67/Devices/CUNO2/CUNO2.c
--- culfw-1.66/Devices/CUNO2/CUNO2.c	2015-04-13 09:03:08.000000000 +0200
+++ culfw-1.67/Devices/CUNO2/CUNO2.c	2017-09-07 15:38:50.000000000 +0200
@@ -128,6 +128,9 @@
 #ifdef HAS_HELIOS
   { 'h', helios_func },
 #endif
+#ifdef HAS_HOERMANN_SEND
+  { 'h', hm_send },
+#endif
 #ifdef HAS_SOMFY_RTS
   { 'Y', somfy_rts_func },
 #endif
diff -uarN culfw-1.66/Devices/CUNO2/board.h culfw-1.67/Devices/CUNO2/board.h
--- culfw-1.66/Devices/CUNO2/board.h	2015-04-30 16:50:52.000000000 +0200
+++ culfw-1.67/Devices/CUNO2/board.h	2017-09-07 15:38:50.000000000 +0200
@@ -137,6 +137,10 @@
 #define HELIOS_EMU_HC          "2823" // This is the house code used to address HELIOS space while using F... commands
 #undef  HAS_HELIOS
 
+#ifndef HAS_HELIOS
+#define HAS_HOERMANN_SEND               // Both helios and hoermann use 'h'
+#endif
+
 #ifdef HAS_DMX
 #undef  HAS_IRTX
 #undef  HAS_IRRX
diff -uarN culfw-1.66/Devices/PCM/board.h culfw-1.67/Devices/PCM/board.h
--- culfw-1.66/Devices/PCM/board.h	1970-01-01 01:00:00.000000000 +0100
+++ culfw-1.67/Devices/PCM/board.h	2017-09-07 15:38:49.000000000 +0200
@@ -0,0 +1,57 @@
+#ifndef _PCMBOARD_H
+#define _PCMBOARD_H
+
+#include "../SCC/board.h"
+
+#undef HAS_STACKING
+
+
+#undef CC1100_IN_DDR
+#undef CC1100_IN_PORT
+#undef CC1100_IN_PIN
+#undef CC1100_IN_IN
+#undef CC1100_INT
+#undef CC1100_INTVECT
+#undef CC1100_ISC
+#undef CC1100_EICR
+
+#define CC1100_IN_DDR		DDRD
+#define CC1100_IN_PORT          PIND
+#define CC1100_IN_PIN           2
+#define CC1100_IN_IN            PINB
+#define CC1100_INT		INT0
+#define CC1100_INTVECT          INT0_vect
+#define CC1100_ISC		ISC00
+#define CC1100_EICR             EICRA
+
+#undef LED_DDR
+#undef LED_PORT
+#undef LED_PIN
+#define LED_DDR                 DDRD
+#define LED_PORT                PORTD
+#define LED_PIN                 4
+
+#define MULTI_FREQ_DEVICE       // available in multiple versions: 433MHz,868MHz,915MHz
+
+#undef MARK433_PORT
+#undef MARK433_PIN
+#undef MARK433_BIT
+
+#define MARK433_PORT            PORTC
+#define MARK433_PIN             PINC    
+#define MARK433_BIT             4
+
+#undef MARK915_PORT
+#undef MARK915_PIN
+#undef MARK915_BIT
+
+#define MARK915_PORT            PORTC
+#define MARK915_PIN             PINC    
+#define MARK915_BIT             5
+
+#define BOARD_ID_STR915         "CSM915"
+
+
+
+#endif
+
diff -uarN culfw-1.66/Devices/PCM/makefile culfw-1.67/Devices/PCM/makefile
--- culfw-1.66/Devices/PCM/makefile	1970-01-01 01:00:00.000000000 +0100
+++ culfw-1.67/Devices/PCM/makefile	2017-09-07 15:38:49.000000000 +0200
@@ -0,0 +1,431 @@
+MCU = atmega1284p
+BOARD  =
+F_CPU = 8000000
+FORMAT = ihex
+TARGET = PCM
+OBJDIR = .
+
+SRC = ../SCC/SCC.c                                                    \
+		../../clib/cc1100.c                                  \
+		../../clib/cc1101_pllcheck.c                         \
+		../../clib/clock.c                                   \
+		../../clib/delay.c                                   \
+		../../clib/display.c                                 \
+		../../clib/stringfunc.c                              \
+		../../clib/fncollection.c                            \
+		../../clib/ringbuffer.c                              \
+		../../clib/rf_send.c                                 \
+		../../clib/rf_asksin.c                               \
+		../../clib/rf_moritz.c                               \
+		../../clib/rf_receive.c                              \
+		../../clib/rf_router.c                               \
+		../../clib/rf_zwave.c                                \
+		../../clib/intertechno.c                             \
+		../../clib/somfy_rts.c				     \
+		../../clib/fht.c                                     \
+		../../clib/fastrf.c                                  \
+		../../clib/memory.c                                  \
+		../../clib/serial.c                                  \
+		../../clib/ttydata.c                                 \
+		../../clib/stacking.c                                \
+		../../clib/spi.c                                     \
+                ../../clib/rf_mbus.c                                 \
+                ../../clib/mbus/manchester.c                         \
+                ../../clib/mbus/3outof6.c                            \
+                ../../clib/mbus/mbus_packet.c                        \
+                ../../clib/mbus/crc.c                                \
+
+
+OPT = s
+DEBUG = dwarf-2
+EXTRAINCDIRS = ../../clib
+CSTANDARD = -std=gnu99
+CDEFS  = -DF_CPU=$(F_CPU)UL
+
+ADEFS = -DF_CPU=$(F_CPU)
+CPPDEFS = -DF_CPU=$(F_CPU)UL
+
+
+CFLAGS = -g$(DEBUG)
+CFLAGS += $(CDEFS)
+CFLAGS += -O$(OPT)
+CFLAGS += -funsigned-char
+CFLAGS += -funsigned-bitfields
+CFLAGS += -ffunction-sections
+CFLAGS += -fpack-struct
+CFLAGS += -fshort-enums
+CFLAGS += -finline-limit=20
+CFLAGS += -Wall
+CFLAGS += -Wstrict-prototypes
+CFLAGS += -Wundef
+#CFLAGS += -Wunreachable-code
+CFLAGS += -Wa,-adhlns=$(<:%.c=$(OBJDIR)/%.lst)
+CFLAGS += $(patsubst %,-I%,$(EXTRAINCDIRS))
+CFLAGS += $(CSTANDARD)
+CFLAGS += -mcall-prologues
+
+
+CPPFLAGS = -g$(DEBUG)
+CPPFLAGS += $(CPPDEFS)
+CPPFLAGS += -O$(OPT)
+CPPFLAGS += -funsigned-char
+CPPFLAGS += -funsigned-bitfields
+CPPFLAGS += -fpack-struct
+CPPFLAGS += -fshort-enums
+CPPFLAGS += -fno-exceptions
+CPPFLAGS += -Wall
+CFLAGS += -Wundef
+CPPFLAGS += -Wa,-adhlns=$(<:%.cpp=$(OBJDIR)/%.lst)
+CPPFLAGS += $(patsubst %,-I%,$(EXTRAINCDIRS))
+
+
+ASFLAGS = $(ADEFS) -Wa,-adhlns=$(<:%.S=$(OBJDIR)/%.lst),-gstabs,--listing-cont-lines=100
+
+
+PRINTF_LIB_MIN = -Wl,-u,vfprintf -lprintf_min
+PRINTF_LIB_FLOAT = -Wl,-u,vfprintf -lprintf_flt
+PRINTF_LIB =
+SCANF_LIB_MIN = -Wl,-u,vfscanf -lscanf_min
+SCANF_LIB_FLOAT = -Wl,-u,vfscanf -lscanf_flt
+SCANF_LIB =
+MATH_LIB = -lm
+EXTRALIBDIRS =
+EXTMEMOPTS =
+
+
+LDFLAGS = -Wl,-Map=$(TARGET).map,--cref
+LDFLAGS += -Wl,--relax
+LDFLAGS += -Wl,--gc-sections
+LDFLAGS += $(EXTMEMOPTS)
+LDFLAGS += $(patsubst %,-L%,$(EXTRALIBDIRS))
+LDFLAGS += $(PRINTF_LIB) $(SCANF_LIB) $(MATH_LIB)
+
+AVRDUDE_NO_VERIFY = -V
+
+#AVRDUDE_PROGRAMMER = jtagmkII
+#AVRDUDE_PORT = usb
+#AVRDUDE_PROGRAMMER = stk500v2
+AVRDUDE_PROGRAMMER = avr109 -b 38400
+AVRDUDE_PORT = /dev/ttyAMA0
+AVRDUDE_WRITE_FLASH = -U flash:w:$(TARGET).hex
+AVRDUDE_FLAGS = -p $(MCU) -P $(AVRDUDE_PORT) -c $(AVRDUDE_PROGRAMMER)
+AVRDUDE_FLAGS += $(AVRDUDE_NO_VERIFY)
+AVRDUDE_FLAGS += $(AVRDUDE_VERBOSE)
+AVRDUDE_FLAGS += $(AVRDUDE_ERASE_COUNTER)
+
+
+DEBUG_MFREQ = $(F_CPU)
+DEBUG_UI = insight
+DEBUG_BACKEND = avarice
+GDBINIT_FILE = __avr_gdbinit
+JTAG_DEV = /dev/com1
+
+DEBUG_PORT = 4242
+DEBUG_HOST = localhost
+
+SHELL = sh
+CC = avr-gcc
+OBJCOPY = avr-objcopy
+OBJDUMP = avr-objdump
+SIZE = avr-size
+AR = avr-ar rcs
+NM = avr-nm
+AVRDUDE = avrdude
+REMOVE = rm -f
+REMOVEDIR = rm -rf
+COPY = cp
+WINSHELL = cmd
+
+MSG_ERRORS_NONE = Errors: none
+MSG_BEGIN = -------- begin --------
+MSG_END = --------  end  --------
+MSG_SIZE_BEFORE = Size before:
+MSG_SIZE_AFTER = Size after:
+MSG_COFF = Converting to AVR COFF:
+MSG_EXTENDED_COFF = Converting to AVR Extended COFF:
+MSG_FLASH = Creating load file for Flash:
+MSG_EEPROM = Creating load file for EEPROM:
+MSG_EXTENDED_LISTING = Creating Extended Listing:
+MSG_SYMBOL_TABLE = Creating Symbol Table:
+MSG_LINKING = Linking:
+MSG_COMPILING = Compiling C:
+MSG_COMPILING_CPP = Compiling C++:
+MSG_ASSEMBLING = Assembling:
+MSG_CLEANING = Cleaning project:
+MSG_CREATING_LIBRARY = Creating library:
+
+
+
+
+OBJ = $(SRC:%.c=$(OBJDIR)/%.o) $(CPPSRC:%.cpp=$(OBJDIR)/%.o) $(ASRC:%.S=$(OBJDIR)/%.o)
+
+LST = $(SRC:%.c=$(OBJDIR)/%.lst) $(CPPSRC:%.cpp=$(OBJDIR)/%.lst) $(ASRC:%.S=$(OBJDIR)/%.lst)
+
+
+GENDEPFLAGS = -MMD -MP -MF .dep/$(@F).d
+
+
+ALL_CFLAGS = -mmcu=$(MCU) -I. $(CFLAGS) $(GENDEPFLAGS)
+ALL_CPPFLAGS = -mmcu=$(MCU) -I. -x c++ $(CPPFLAGS) $(GENDEPFLAGS)
+ALL_ASFLAGS = -mmcu=$(MCU) -I. -x assembler-with-cpp $(ASFLAGS)
+
+
+
+all: sizebefore build sizeafter
+
+build: elf hex eep lss sym
+
+
+elf: $(TARGET).elf
+hex: $(TARGET).hex
+eep: $(TARGET).eep
+lss: $(TARGET).lss
+sym: $(TARGET).sym
+LIBNAME=lib$(TARGET).a
+lib: $(LIBNAME)
+
+
+
+begin:
+	@echo
+	@echo $(MSG_BEGIN)
+
+end:
+	@echo $(MSG_END)
+	@echo
+
+
+HEXSIZE = $(SIZE) $(TARGET).hex
+ELFSIZE = $(SIZE) $(TARGET).elf
+
+sizebefore:
+	@if test -f $(TARGET).elf; then echo; echo $(MSG_SIZE_BEFORE); $(ELFSIZE); \
+	2>/dev/null; echo; fi
+
+sizeafter:
+	@if test -f $(TARGET).elf; then echo; echo $(MSG_SIZE_AFTER); $(ELFSIZE); \
+	2>/dev/null; echo; fi
+
+checkhooks: build
+	@echo
+	@echo ------- Unhooked MyUSB Events -------
+	@$(shell) (grep -s '^Event.*MyUSB/.*\\.o' $(TARGET).map | \
+	           cut -d' ' -f1 | cut -d'_' -f2- | grep ".*") || \
+			   echo "(None)"
+	@echo ----- End Unhooked MyUSB Events -----
+
+checklibmode:
+	@echo
+	@echo ----------- Library Mode -----------
+	@$(shell) ($(CC) $(ALL_CFLAGS) -E -dM - < /dev/null \
+	          | grep 'USB_\(DEVICE\|HOST\)_ONLY' | cut -d' ' -f2 | grep ".*") \
+	          || echo "No specific mode (both device and host mode allowable)."
+	@echo ------------------------------------
+
+gccversion :
+	@$(CC) --version
+
+start:
+	@echo
+	@echo starting ...
+	@echo
+	if test ! -d /sys/class/gpio/gpio102; then echo 102 > /sys/class/gpio/export; fi
+	echo out > /sys/class/gpio/gpio102/direction
+	echo 1 > /sys/class/gpio/gpio102/value
+
+iprogram:
+	$(AVRDUDE) $(AVRDUDE_FLAGS) $(AVRDUDE_WRITE_FLASH)
+
+program: $(TARGET).hex
+	@echo
+	@echo calling radio frontends bootloader on RPi PIGATOR OW / POD ...
+	@echo
+	if test ! -d /sys/class/gpio/gpio22; then echo 22 > /sys/class/gpio/export; fi
+	echo out > /sys/class/gpio/gpio22/direction
+	echo 0 > /sys/class/gpio/gpio22/value
+
+	if test ! -d /sys/class/gpio/gpio27; then echo 27 > /sys/class/gpio/export; fi
+	echo out > /sys/class/gpio/gpio27/direction
+	echo 0 > /sys/class/gpio/gpio27/value
+
+	echo 1 > /sys/class/gpio/gpio22/value
+	sleep 1
+	echo 1 > /sys/class/gpio/gpio22/value
+	echo in > /sys/class/gpio/gpio27/direction
+	echo 27 > /sys/class/gpio/unexport
+
+	$(AVRDUDE) $(AVRDUDE_FLAGS) $(AVRDUDE_WRITE_FLASH)
+
+	echo 0 > /sys/class/gpio/gpio22/value
+	sleep 1
+	echo 1 > /sys/class/gpio/gpio22/value
+
+program_isp: $(TARGET).hex $(TARGET).eep
+	$(AVRDUDE) $(AVRDUDE_FLAGS) $(AVRDUDE_WRITE_FLASH) $(AVRDUDE_WRITE_EEPROM) -U lfuse:w:0xc2:m -U hfuse:w:0x99:m
+
+erase:
+	$(AVRDUDE) $(AVRDUDE_FLAGS) -e
+
+
+usbprogram: $(TARGET).hex
+	$(AVRDUDE) $(AVRDUDE_FLAGS) $(AVRDUDE_WRITE_FLASH)
+
+deb: $(TARGET).hex
+	echo $(PWD)
+	rm -rf .f $(DESTDIR) *.deb
+	mkdir -p .f/boot
+	cp -r DEBIAN .f/
+	rm -fr .f/DEBIAN/CVS
+	cp $(TARGET).hex .f/boot/culfw-s0logger.hex
+	find .f -type f -print | xargs perl -pi -e 's/=VERS=/$(VERS)/g;s/=DATE=/$(DATE)/g'
+	chown -R root:root .f
+	mv .f $(DESTDIR)
+	dpkg-deb --build $(DESTDIR)
+	rm -rf $(DESTDIR)
+	scp $(DESTDIR).deb busware.de:/srv/ftp/debian/dists/tuxrail2/main/
+	@echo run /root/update_apt.sh
+
+
+gdb-config:
+	@$(REMOVE) $(GDBINIT_FILE)
+	@echo define reset >> $(GDBINIT_FILE)
+	@echo SIGNAL SIGHUP >> $(GDBINIT_FILE)
+	@echo end >> $(GDBINIT_FILE)
+	@echo file $(TARGET).elf >> $(GDBINIT_FILE)
+	@echo target remote $(DEBUG_HOST):$(DEBUG_PORT)  >> $(GDBINIT_FILE)
+ifeq ($(DEBUG_BACKEND),simulavr)
+	@echo load  >> $(GDBINIT_FILE)
+endif
+	@echo break main >> $(GDBINIT_FILE)
+
+debug: gdb-config $(TARGET).elf
+ifeq ($(DEBUG_BACKEND), avarice)
+	@echo Starting AVaRICE - Press enter when "waiting to connect" message displays.
+	@$(WINSHELL) /c start avarice --jtag $(JTAG_DEV) --erase --program --file \
+	$(TARGET).elf $(DEBUG_HOST):$(DEBUG_PORT)
+	@$(WINSHELL) /c pause
+
+else
+	@$(WINSHELL) /c start simulavr --gdbserver --device $(MCU) --clock-freq \
+	$(DEBUG_MFREQ) --port $(DEBUG_PORT)
+endif
+	@$(WINSHELL) /c start avr-$(DEBUG_UI) --command=$(GDBINIT_FILE)
+
+
+
+
+COFFCONVERT = $(OBJCOPY) --debugging
+COFFCONVERT += --change-section-address .data-0x800000
+COFFCONVERT += --change-section-address .bss-0x800000
+COFFCONVERT += --change-section-address .noinit-0x800000
+COFFCONVERT += --change-section-address .eeprom-0x810000
+
+
+
+coff: $(TARGET).elf
+	@echo
+	@echo $(MSG_COFF) $(TARGET).cof
+	$(COFFCONVERT) -O coff-avr $< $(TARGET).cof
+
+
+extcoff: $(TARGET).elf
+	@echo
+	@echo $(MSG_EXTENDED_COFF) $(TARGET).cof
+	$(COFFCONVERT) -O coff-ext-avr $< $(TARGET).cof
+
+
+
+%.hex: %.elf
+	@echo $(MSG_FLASH) $@
+	@$(OBJCOPY) -O $(FORMAT) -R .eeprom $< $@
+
+%.eep: %.elf
+	@echo $(MSG_EEPROM) $@
+	@-$(OBJCOPY) -j .eeprom --set-section-flags=.eeprom="alloc,load" \
+	--change-section-lma .eeprom=0 --no-change-warnings -O $(FORMAT) $< $@ || exit 0
+
+%.lss: %.elf
+	@echo $(MSG_EXTENDED_LISTING) $@
+	@$(OBJDUMP) -h -z -S $< > $@
+
+%.sym: %.elf
+	@echo $(MSG_SYMBOL_TABLE) $@
+	@$(NM) -n $< > $@
+
+
+
+.SECONDARY : $(TARGET).a
+.PRECIOUS : $(OBJ)
+%.a: $(OBJ)
+	@echo
+	@echo $(MSG_CREATING_LIBRARY) $@
+	$(AR) $@ $(OBJ)
+
+
+.SECONDARY : $(TARGET).elf
+.PRECIOUS : $(OBJ)
+%.elf: $(OBJ)
+	@echo $(MSG_LINKING) $@
+	@$(CC) $(ALL_CFLAGS) $^ --output $@ $(LDFLAGS)
+
+
+$(OBJDIR)/%.o : %.c
+	@echo $(MSG_COMPILING) $<
+	@$(CC) -c $(ALL_CFLAGS) $< -o $@
+
+
+$(OBJDIR)/%.o : %.cpp
+	@echo
+	@echo $(MSG_COMPILING_CPP) $<
+	$(CC) -c $(ALL_CPPFLAGS) $< -o $@
+
+
+%.s : %.c
+	$(CC) -S $(ALL_CFLAGS) $< -o $@
+
+
+%.s : %.cpp
+	$(CC) -S $(ALL_CPPFLAGS) $< -o $@
+
+
+$(OBJDIR)/%.o : %.S
+	@echo
+	@echo $(MSG_ASSEMBLING) $<
+	$(CC) -c $(ALL_ASFLAGS) $< -o $@
+
+
+%.i : %.c
+	$(CC) -E -mmcu=$(MCU) -I. $(CFLAGS) $< -o $@
+
+clean: clean_list clean_binary
+
+clean_binary:
+	@$(REMOVE) $(TARGET).hex
+
+clean_list:
+	@echo $(MSG_CLEANING)
+	@$(REMOVE) $(TARGET).eep
+	@$(REMOVE) $(TARGET).cof
+	@$(REMOVE) $(TARGET).elf
+	@$(REMOVE) $(TARGET).map
+	@$(REMOVE) $(TARGET).sym
+	@$(REMOVE) $(TARGET).lss
+	@$(REMOVE) $(SRC:%.c=$(OBJDIR)/%.o)
+	@$(REMOVE) $(SRC:%.c=$(OBJDIR)/%.lst)
+	@$(REMOVE) $(SRC:.c=.s)
+	@$(REMOVE) $(SRC:.c=.d)
+	@$(REMOVE) $(SRC:.c=.i)
+	@$(REMOVEDIR) .dep
+
+
+$(shell mkdir $(OBJDIR) 2>/dev/null)
+
+
+-include $(shell mkdir .dep 2>/dev/null) $(wildcard .dep/*)
+
+
+.PHONY : all checkhooks checklibmode begin  \
+finish end sizebefore sizeafter gccversion  \
+build elf hex eep lss sym coff extcoff      \
+clean clean_list clean_binary program debug \
+gdb-config
diff -uarN culfw-1.66/Devices/SCC/SCC.c culfw-1.67/Devices/SCC/SCC.c
--- culfw-1.66/Devices/SCC/SCC.c	2015-12-11 17:12:40.000000000 +0100
+++ culfw-1.67/Devices/SCC/SCC.c	2017-09-07 15:38:50.000000000 +0200
@@ -99,6 +99,9 @@
 #endif
 #ifdef HAS_STACKING
   { '*', stacking_func },
+#ifdef HAS_STACK_ENOCEAN  
+  { '%', stacking_func_eno },
+#endif
 #endif
   { 'l', ledfunc },
   { 't', gettime },
diff -uarN culfw-1.66/Devices/SCC/board.h culfw-1.67/Devices/SCC/board.h
--- culfw-1.66/Devices/SCC/board.h	2015-12-11 17:12:40.000000000 +0100
+++ culfw-1.67/Devices/SCC/board.h	2017-09-07 15:38:50.000000000 +0200
@@ -85,9 +85,10 @@
 #define HAS_UART                1
 #define UART_BAUD_RATE          38400
 
-#define TTY_BUFSIZE             128
+#define TTY_BUFSIZE             512  /* EnOcean needs 2*sizeof(mycmd[])) */
 
 #define HAS_STACKING
+#define HAS_STACK_ENOCEAN
 
 #define BUSWARE_CSM
 #define BUSWARE_SCC
diff -uarN culfw-1.66/Devices/nanoCUL/board.h culfw-1.67/Devices/nanoCUL/board.h
--- culfw-1.66/Devices/nanoCUL/board.h	2015-02-08 19:52:38.000000000 +0100
+++ culfw-1.67/Devices/nanoCUL/board.h	2017-09-07 15:38:50.000000000 +0200
@@ -106,6 +106,7 @@
 #define HAS_TX3
 #define HAS_UNIROLL
 #define HAS_HOERMANN
+#define HAS_HOERMANN_SEND
 #define HAS_MEMFN
 #define HAS_SOMFY_RTS
 #define HAS_FHT_80b                     // PROGMEM: 1374b, RAM: 90b
@@ -113,6 +114,7 @@
 #define HAS_FHT_TF
 #define FHTBUF_SIZE          174      //                 RAM: 174b
 #define HAS_KOPP_FC
+#define HAS_ZWAVE                     // PROGMEM:  882
 
 
 #endif
diff -uarN culfw-1.66/Devices/nanoCUL/makefile culfw-1.67/Devices/nanoCUL/makefile
--- culfw-1.66/Devices/nanoCUL/makefile	2015-02-02 20:14:09.000000000 +0100
+++ culfw-1.67/Devices/nanoCUL/makefile	2017-09-07 15:38:50.000000000 +0200
@@ -29,6 +29,7 @@
 		../../clib/rf_rwe.c                               \
 		../../clib/somfy_rts.c                               \
 		../../clib/fastrf.c                               \
+		../../clib/rf_zwave.c                                \
 		../../clib/intertechno.c                             \
 		../../clib/kopp-fc.c                                 \
 		../../clib/memory.c                                  \
diff -uarN culfw-1.66/Devices/nanoCUL/nanoCUL.c culfw-1.67/Devices/nanoCUL/nanoCUL.c
--- culfw-1.66/Devices/nanoCUL/nanoCUL.c	2016-01-20 21:48:53.000000000 +0100
+++ culfw-1.67/Devices/nanoCUL/nanoCUL.c	2017-09-07 15:38:50.000000000 +0200
@@ -35,6 +35,7 @@
 #include "adcw.h"
 #include "cctemp.h"
 #include "fht.h"
+#include "memory.h"
 
 #ifdef HAS_ASKSIN
 #include "rf_asksin.h"
@@ -57,6 +58,9 @@
 #ifdef HAS_KOPP_FC
 #include "kopp-fc.h"
 #endif
+#ifdef HAS_ZWAVE
+#include "rf_zwave.h"
+#endif
 
 
 
@@ -68,63 +72,73 @@
 
 const PROGMEM t_fntab fntab[] = {
 
+#ifdef HAS_ASKSIN
+  { 'A', asksin_func },
+#endif
   { 'B', prepare_boot },
 #ifdef HAS_MBUS
   { 'b', rf_mbus_func },
 #endif
   { 'C', ccreg },
+#ifdef HAS_RWE
+  { 'E', rwe_func },
+#endif
+  { 'e', eeprom_factory_reset },
   { 'F', fs20send },
-#ifdef HAS_INTERTECHNO
-  { 'i', it_func },
+#ifdef HAS_FASTRF
+  { 'f', fastrf_func },
 #endif
-#ifdef HAS_ASKSIN
-  { 'A', asksin_func },
+#ifdef HAS_RAWSEND
+  { 'G', rawsend },
 #endif
-#if defined (HAS_IRRX) || defined (HAS_IRTX)
-  { 'I', ir_func },
+#ifdef HAS_HOERMANN_SEND
+  { 'h', hm_send },
 #endif
-#ifdef HAS_MORITZ
-  { 'Z', moritz_func },
+#ifdef HAS_INTERTECHNO
+  { 'i', it_func },
 #endif
-#ifdef HAS_RWE
-  { 'E', rwe_func },
+#ifdef HAS_RAWSEND
+  { 'K', ks_send },
 #endif
 #ifdef HAS_KOPP_FC
   { 'k', kopp_fc_func },
-#endif  
-#ifdef HAS_ONEWIRE
-  { 'O', onewire_func },
 #endif
+#ifdef HAS_BELFOX
+  { 'L', send_belfox },
+#endif
+  { 'l', ledfunc },
 #ifdef HAS_RAWSEND
-  { 'G', rawsend },
   { 'M', em_send },
-  { 'K', ks_send },
 #endif
-#ifdef HAS_UNIROLL
-  { 'U', ur_send },
+#ifdef HAS_MEMFN
+  { 'm', getfreemem },
 #endif
-#ifdef HAS_SOMFY_RTS
-  { 'Y', somfy_rts_func },
+#ifdef HAS_RFNATIVE
+  { 'N', native_func },
 #endif
   { 'R', read_eeprom },
   { 'T', fhtsend },
-  { 'V', version },
-  { 'W', write_eeprom },
-  { 'X', set_txreport },
-
-  { 'e', eeprom_factory_reset },
- // { 'h', cctemp_func },       // HU: hömérsék :)
-  
-#ifdef HAS_FASTRF
-  { 'f', fastrf_func },
-#endif
-  { 'l', ledfunc },
   { 't', gettime },
+#ifdef HAS_UNIROLL
+  { 'U', ur_send },
+#endif
 #ifdef HAS_RF_ROUTER
   { 'u', rf_router_func },
 #endif
+  { 'V', version },
+  { 'W', write_eeprom },
+  { 'X', set_txreport },
   { 'x', ccsetpa },
-
+#ifdef HAS_SOMFY_RTS
+  { 'Y', somfy_rts_func },
+#endif
+#ifdef HAS_MORITZ
+  { 'Z', moritz_func },
+#endif
+#ifdef HAS_ZWAVE
+  { 'z', zwave_func },
+#endif
+  { 0, 0 },
   { 0, 0 },
 };
 
@@ -207,6 +221,9 @@
 #ifdef HAS_MBUS
     rf_mbus_task();
 #endif
+#ifdef HAS_ZWAVE
+    rf_zwave_task();
+#endif
   }
 
 }
diff -uarN culfw-1.66/clib/Descriptors.c culfw-1.67/clib/Descriptors.c
--- culfw-1.66/clib/Descriptors.c	2012-11-27 23:12:52.000000000 +0100
+++ culfw-1.67/clib/Descriptors.c	2017-09-07 15:38:51.000000000 +0200
@@ -236,7 +236,7 @@
           break;
         case 0x02:
 #ifdef MULTI_FREQ_DEVICE
-          if (!bit_is_set(PINB, PB6))
+          if (!bit_is_set(MARK433_PIN, MARK433_BIT))
             Address = DESCRIPTOR_ADDRESS(ProductString433);
           else
 #endif
diff -uarN culfw-1.66/clib/kopp-fc.c culfw-1.67/clib/kopp-fc.c
--- culfw-1.66/clib/kopp-fc.c	2015-04-22 22:59:24.000000000 +0200
+++ culfw-1.67/clib/kopp-fc.c	2017-09-07 15:38:51.000000000 +0200
@@ -25,8 +25,9 @@
  *				 
  *	 Pameter String definition (receive): 	krS krE 
  *   "k":		command will be routed to Kopp-fc
- *   "r" 		Command is "receive
- *   "S" or "E"	"S" will start Receive mode, "E" will end receive mode
+ *   "r": 		Command is "receive
+ *   "S" or "E" "S" will start Receive mode, "E" will end receive mode
+ *   "1" or "2": Optional Parameter for debugging only "1" will show each received block, "2" will show any received bytes, incl. zeros....
  *
  *	 some hints:
  *   =========== 
@@ -40,16 +41,19 @@
  *					
  * Date		   Who				Comment																												   
  * ----------  -------------   	-------------------------------------------------------------------------------------------------------------------------------
- * 2015-04-21  Claus M.			first version of Receive mode (used rf_mbus as example) implemented, usage only in terminal, yet
- * 2015-02-01  Claus M.			Changed Line-Endings to Unix style, changed comment above (this routine will be called from FHEM with "k" (little) and no more "K"
+ * 2016-04.04  RaspII			Added Debug Information and additional Watchdog handling (no more watchdog resets reported by Feuerdrache)
+ * 2016-03-29  RaspII           Generate no error messages anymore for Receive Checksum Errors
+ * 2016-02-22  RaspII			Received blocks (HF) are only accepted if blocklength = 7
+ * 2015-04-21  RaspII			first version of Receive mode (used rf_mbus as example) implemented, usage only in terminal, yet
+ * 2015-02-01  RaspII			Changed Line-Endings to Unix style, changed comment above (this routine will be called from FHEM with "k" (little) and no more "K"
  *                              removed useless lines
- * 2014-12-13  Claus M.			set Baudrate to 83 hex (previously 82)
- * 2014-12-13  Claus M.			Added Print Option because else FHEM will provide error messages to logfile
- * 2014-12-06  Claus M.			Added second command "s" for transmitt on data block only (no "Key off" code will be sent)
+ * 2014-12-13  RaspII			set Baudrate to 83 hex (previously 82)
+ * 2014-12-13  RaspII			Added Print Option because else FHEM will provide error messages to logfile
+ * 2014-12-06  RaspII			Added second command "s" for transmitt on data block only (no "Key off" code will be sent)
  *								Tansmitter Code was not sent, added Transmitter Code 2
- * 2014-08-29  Claus M.			Added "Long Key Preasure" (Remote control key pressed for x msec) 
- * 2014-08-08  Claus M.			Now transmitting one block is working with Kopp Free Control protocol, key Code from Input parameter (1 character)
- * 2014-08-01  Claus M.			first Version
+ * 2014-08-29  RaspII			Added "Long Key Preasure" (Remote control key pressed for x msec) 
+ * 2014-08-08  RaspII			Now transmitting one block is working with Kopp Free Control protocol, key Code from Input parameter (1 character)
+ * 2014-08-01  RaspII			first Version
  *
  * 
  * ------------------------------------------------------------------------------------------------------------------------------------------------------------
@@ -90,6 +94,7 @@
 uint8_t kopp_fc_on = 0;
 uint8_t kopp_fc_rx_on = 0;
 uint8_t kopp_fc_tx_on = 0;
+uint8_t kopp_fc_debug_lvl = 0;					// Debug Level for Receive Mode
 
 
 uint8_t blkctr;
@@ -236,6 +241,8 @@
 
 
 
+
+
 // Transmitt data block for Kopp Free Control
 // ------------------------------------------------------------------------------------------------------------------------------------------
 void TransmittKoppBlk(uint8_t sendmsg01[15], uint8_t blkTXcode_i)
@@ -369,6 +376,8 @@
 
 if(in[1] == 's') SingleBlkOnly=1;								// Command = "s", -> If KeyCode > 0x80 we will send no !! Key Off Code
 
+wdt_reset();													// 2016-04-04: ####RaspII Watchdog reset for Feuerdrache to test issues
+
 LastWatchdog=ticks;												// I guess, Watchdog reset was done shortly before 
 BlockStartTime=ticks;
 
@@ -563,7 +572,8 @@
 // ========================
     {
 	kopp_fc_rx_on = 0;
-	ccStrobe( CC1100_SIDLE);										// CC11xx goes idle again	
+	ccStrobe( CC1100_SIDLE);										// CC11xx goes idle again
+	kopp_fc_debug_lvl = 0;	
 //	kopp_fc_init();
 	DS_P(PSTR("krE-ReceiveEnd\r\n"));
     }
@@ -573,7 +583,14 @@
 
 // Receive Start command
 // ---------------------
+// ## RaspII Here I will add a debug level parameter later on to display all received blocks or even all received bytes
+
 	{
+
+     if(in[3] == '1') kopp_fc_debug_lvl = 1;							// define debuglevel
+	 else if (in[3] =='2') kopp_fc_debug_lvl = 2;
+	 else kopp_fc_debug_lvl = 0;	
+
 	kopp_fc_rx_on = 1;
 	kopp_fc_init();													// Init CC11xx for Kopp Free Control protocol (common init subroutine, later we will call this 
 																	// subroutine only if basic initialization was not done before)
@@ -639,15 +656,25 @@
  // RX active, awaiting SYNC
 
 // if (bit_is_set(GDO2_PIN,GDO2_BIT)) 
- if (bit_is_set( CC1100_IN_PORT, CC1100_IN_PIN ))
+ if (bit_is_set( CC1100_IN_PORT, CC1100_IN_PIN ))					// GDO2=CC100_IN_Port sind so konfirguriert, dass dieser aktiv=high wird
+																	// sobald ein kompletter Kopp Block (15 Bytes) oder mehr als 20Bytes im RX-Fifo sind
  {
+
+  wdt_reset();														// 2016-04-04: ####RaspII Watchdog reset for Feuerdrache to test reset issues
+
 																	// errata #1 does not affect us, because we wait until packet is completely received
 //  recbuf[0] = cc1100_readReg( CC1100_RXFIFO ) & 0x7f; 			// read how much data if first byte in Fifo is blklen
   recbuf[0] = cc1100_readReg( CC1100_RXBYTES ) & 0x7f; 			// read how much data in fifo
+  
+  if(kopp_fc_debug_lvl == 2) 										// <Print Bytes received in Fifo Debuglevel = 2>
+  {
+   DS_P(PSTR("Bytes in Fifo: "));
+   DH2(recbuf[0]);
+   DS_P(PSTR("  Received Data: "));
+  }
+  
 
- if (recbuf[0]>=MAX_kopp_fc_MSG)
-     recbuf[0] = MAX_kopp_fc_MSG;
-
+  if (recbuf[0]>=MAX_kopp_fc_MSG) recbuf[0] = MAX_kopp_fc_MSG;		// If more bytes than overal block size (incl. Zeros) ignore remaining fifo content
 
 //  DS_P(PSTR("BlkStart  "));										// For test only
 //  DH2(recbuf[0]);
@@ -663,9 +690,6 @@
   for (uint8_t i=0; i<recbuf[0]; i++) 								// Fifo lesen
   {
    recbuf[i+1] = cc1100_sendbyte( 0 );
-   
-   
-   
 
    if (i < 7+1)                                    					// calculate Checksum for  Receive Bytes 0...7 (=recbuf[1...8])
      {																// ------------------------------------------------------------
@@ -675,35 +699,45 @@
    if ((i == 8) && (blkcks!=recbuf[i+1]))            				// Compare Checksum in Buffer to calculated Checksum 
      {																// ------------------------------------------------------------
       recckserr=1;					                    			// Checksum Error !
-	  DH2(recbuf[i+1]);
-	  DS_P(PSTR(" Checksum Error\r\n"));							// For test only
      }                                                    			//
    
-//   DH2(recbuf[i+1]);												// print all received bytes
+	 if(kopp_fc_debug_lvl == 2) DH2(recbuf[i+1]);					// <Print any received Bytes if Debuglevel = 2>
 
-  }
-  CC1100_DEASSERT;
-//  DS_P(PSTR("\r\n"));												// For test only
+   }
+   CC1100_DEASSERT;
+
+	if(kopp_fc_debug_lvl == 2) DS_P(PSTR("\r\n"));					// <Print Linefeed if Debuglevel = 2>
 
 
 
-  if ((memcmp(recbuf, lastrecblk, MAX_kopp_fc_NetMSG+1) != 0 ) && (recckserr!=1))			
-	{																// If new Block not equal old block (without zeros at the end) and Checksum is fine -> new command received
-																	// --------------------------------------------------------------------------------------------
+  if (((memcmp(recbuf, lastrecblk, MAX_kopp_fc_NetMSG+1) != 0 ) && (recbuf[1]==7) && (recbuf[0] >= MAX_kopp_fc_NetMSG) && (recckserr!=1) && (kopp_fc_debug_lvl != 2)) || (kopp_fc_debug_lvl == 1))			
+	{																// If (new Block not equal old block (without zeros at the end) and an Blocklength=7 
+																	// and minimum one whole kopp message received and debuglevel <> 2) or debuglevel = 1 
+																	// either Checksum is fine -> new command received; or print any block for debug purpose
+																	// ------------------------------------------------------------------------------------------------------------------------------
 	 DS_P(PSTR("kr"));												// Feed Back to FHEM: Was Kopp Receive + Received Data
      memcpy(lastrecblk, recbuf, MAX_kopp_fc_MSG+1);				// save new command (copy whole block incl. Fifo len information)
      for (uint8_t i=0; i<MAX_kopp_fc_NetMSG; i++)	 				// Read Receive String and ...
 	 {																//
       DH2(recbuf[i+1]);											// print all received bytes
      }
-      DS_P(PSTR("\r\n"));											// For test only
+	  if(kopp_fc_debug_lvl == 1) 									// 
+	  {
+       if (recckserr == 1)											// <Print Checksum Error information if Debuglevel = 1>
+	   {
+	   DS_P(PSTR(" Checksum Error, Calculated Cks: "));			// 
+	   DH2(blkcks);
+	   }
+	  }
+
+      DS_P(PSTR("\r\n"));											// 
 
     }
 
  } 
 }
 
-// ####Claus  Hier gehts weiter. Synthesizer Calibration sollte im Empfangs Mode ab und an gemacht werden 
+// ####RaspII  Hier gehts weiter. Synthesizer Calibration sollte im Empfangs Mode ab und an gemacht werden 
 // noch messen wie schnell die _task hintereinander aufgerufen wird !!!!
  
 
diff -uarN culfw-1.66/clib/rf_evohome.c culfw-1.67/clib/rf_evohome.c
--- culfw-1.66/clib/rf_evohome.c	1970-01-01 01:00:00.000000000 +0100
+++ culfw-1.67/clib/rf_evohome.c	2017-09-07 15:38:51.000000000 +0200
@@ -0,0 +1,735 @@
+/*****************************************************************************/
+/*                                                                           */
+/* Honeywell Evohome/Evotouch/Ramses support                                 */
+/*                                                                           */
+/* This module builds on infomation gleaned from many sources, but was       */
+/* written by Colin Tregenza Dancer                                          */
+/*                                                                           */
+/*****************************************************************************/
+
+#include "board.h"
+#ifdef HAS_EVOHOME
+#include <string.h>
+#include <avr/interrupt.h>
+#include <avr/pgmspace.h>
+#include "delay.h"
+#include "display.h"
+#include "clock.h"
+#include "rf_evohome.h"
+#include "cc1100.h"
+
+/*****************************************************************************/
+/* Manchester encode - Needing just 16 bytes, the encode array is a worth    */
+/* using.  Caller's responsibility to only pass nibbles, but anding for      */
+/* safety.                                                                   */
+/*****************************************************************************/
+#define MANCHESTER_ENCODE(X) (manchester_encode[(0xF&((uint8_t)(X)))])
+uint8_t manchester_encode[16]={0xAA,0xA9,0xA6,0xA5,0x9A,0x99,0x96,0x95,0x6A,0x69,0x66,0x65,0x5A,0x59,0x56,0x55};
+
+/*****************************************************************************/
+/* Memory compact manchester decode                                          */
+/*                                                                           */
+/* Used XOR for fast validity test                                           */
+/*                                                                           */
+/* Return: valid data => 0x0-0xF, invalid=0xFF                               */
+/*****************************************************************************/
+#define MANCHESTER_DECODE(X) manchester_decode(X)
+uint8_t manchester_decode(uint8_t data);
+uint8_t manchester_decode(uint8_t data)
+{
+  return((((data&0x55)^((data&0xAA)>>1)) == 0x55) ? ((((data & 0x06)>>1) | ((data & 0x60)>>3)) ^ 0x05) : 0xFF);
+}
+
+/*****************************************************************************/
+/* Working variables shared with ISR                                         */
+/*                                                                           */
+/* Options to use a message based ring buffer, but testing currently shows   */
+/* that a single send/receive buffer with ISR driven tx & rx give good       */
+/* performance.                                                              */
+/*                                                                           */
+/* To be a good neighbour, buffer limited to 64bytes.  The message format    */
+/* allows upto around 270, but 64 is enough for the largest observed 12-zone */
+/* EvoTouch system, including schedule updates (which always appear to be    */
+/* broken into chunks).                                                      */
+/*                                                                           */
+/*****************************************************************************/
+#define MAX_EVOHOME_MSG 64
+static volatile uint8_t msg[MAX_EVOHOME_MSG]={0};
+static volatile uint8_t msg_pos = 0;
+static volatile uint8_t msg_len = 0;
+static volatile uint8_t chksum=0;
+static volatile uint8_t abort=0;
+static uint8_t debug=0;
+
+static volatile uint8_t work_index;
+static volatile uint8_t work[2];
+
+/*****************************************************************************/
+/* Primary states                                                            */
+/*****************************************************************************/
+#define STATE_OFF    0  // Must be zero for easy active check
+#define STATE_IDLE   1
+#define STATE_LISTEN 2
+#define STATE_RX     3
+#define STATE_TX     4
+#define STATE_CAL    5
+
+static volatile uint8_t state=STATE_OFF;
+
+/*****************************************************************************/
+/* The Rx & Tx substates need to be in the order of progression              */
+/*****************************************************************************/
+#define SUBSTATE_IDLE         0
+#define SUBSTATE_RX_PREAMBLE  1
+#define SUBSTATE_RX_DATA      2
+#define SUBSTATE_RX_POSTAMBLE 3
+#define SUBSTATE_RX_DONE      4
+#define SUBSTATE_TX_PREAMBLE  5
+#define SUBSTATE_TX_DATA      6
+#define SUBSTATE_TX_POSTAMBLE 7
+
+static volatile uint8_t substate=SUBSTATE_IDLE;
+
+/*****************************************************************************/
+/* Macro to be used for all state manipulation                               */
+/*****************************************************************************/
+#define SET_STATE(X,Y) {substate=(Y);state=(X);if(debug){if (((state==STATE_RX)&&(substate > SUBSTATE_RX_PREAMBLE))||(state==STATE_TX)){LED_ON();}else{LED_OFF();}}};
+#define SET_SUBSTATE(Z) {SET_STATE(state,(Z))}
+
+
+/*****************************************************************************/
+/* Rx abort handling                                                         */
+/*                                                                           */
+/* Either aborts are silent, or we generate diagnostics that may be useful   */
+/* in diagnosing reception and code problems.                                */
+/*****************************************************************************/
+#define RX_ABORT(X) {if (debug) {abort=(X);SET_SUBSTATE(SUBSTATE_RX_DONE);}else{SET_STATE(STATE_LISTEN,SUBSTATE_IDLE);}}
+
+/*****************************************************************************/
+/* Fixed message segments                                                    */
+/*****************************************************************************/
+#define PREAMBLE_LEN 10
+uint8_t preamble[PREAMBLE_LEN] = {0x55,0x55,0x55,0x55,0x55,0xFF,0x00,0x33,0x55,0x53};
+#define MATCH_OFFSET 6
+
+#define POSTAMBLE_LEN 4
+uint8_t postamble[POSTAMBLE_LEN] = {0x35,0x55,0x55,0x55};
+
+/*****************************************************************************/
+/* Honeywell protocol uses 38K4 8N1 async                                    */
+/*****************************************************************************/
+#define BAUD 38400
+#define USE_2X
+#include <util/setbaud.h>
+void uart1_initialize(void);
+
+/*****************************************************************************/
+/* Configure chip for true async opertion to USART                           */
+/*****************************************************************************/
+const uint8_t PROGMEM EVOHOME_CFG_ASYNC_38400[] = {
+  CC1100_IOCFG2,    0x0D, // 00 GDO2 pin config:   0D: Async Rx data output
+  CC1100_IOCFG0,    0x2D, // 02 GDO0 pin config:   2E: Tri-state (used as input during Tx)   (other code suggests 0x2D
+
+  CC1100_FIFOTHR,   0x01, // 03 FIFO Threshhold                   Not used
+  CC1100_PKTLEN,    0xff, // 06 Packet length
+  CC1100_PKTCTRL1,  0x00, // 07 Packet automation control         00:no crc/addr
+  CC1100_PKTCTRL0,  0x32, // 08 Packet automation control         async + infinite
+  CC1100_FSCTRL1,   0x06, // 0B Frequency synthesizer control
+
+  CC1100_FREQ2,     0x21, // 0D Frequency control word, high byte 868.4MHz
+  CC1100_FREQ1,     0x65, // 0E Frequency control word, middle byte
+  CC1100_FREQ0,     0x6c, // 0F Frequency control word, low byte
+  CC1100_MDMCFG4,   0x6a, // 10 Modem configuration
+  CC1100_MDMCFG3,   0x83, // 11 Modem configuration
+  CC1100_MDMCFG2,   0x10, // 12 Modem configuration      GFSK/No Manchester, preamble or sync
+  CC1100_MDMCFG1,   0x22, // 13 Modem configuration
+  CC1100_DEVIATN,   0x50, // 15 Modem deviation setting
+
+  CC1100_MCSM0,     0x18, // 18 Main Radio Cntrl State Machine config
+  CC1100_FOCCFG,    0x16, // 19 Frequency Offset Compensation config
+  CC1100_AGCCTRL2,  0x43, // 1B AGC control
+  CC1100_AGCCTRL1,  0x40, // 1C AGC control
+  CC1100_AGCCTRL0,  0x91, // 1D AGC control
+  CC1100_FSCAL3,    0xe9, // 23 Frequency synthesizer calibration
+  CC1100_FSCAL2,    0x2a, // 24 Frequency synthesizer calibration
+  CC1100_FSCAL1,    0x00, // 25 Frequency synthesizer calibration
+  CC1100_FSCAL0,    0x1f, // 26 Frequency synthesizer calibration
+  CC1100_PATABLE,   0x50  // 3E
+};
+
+/*****************************************************************************/
+/* Major C1100 state change routines                                         */
+/*****************************************************************************/
+
+/*****************************************************************************/
+/* In listen mode we're looking for valid messages                           */
+/*****************************************************************************/
+void evohome_LISTEN(void)
+{
+  SET_STATE(STATE_LISTEN,SUBSTATE_IDLE);
+  UCSR1B = _BV(RXCIE1) | _BV(RXEN1); // RX Complete IRQ enabled, Receiver enable
+  ccRX();
+  EIMSK &= ~_BV(CC1100_INT);                 // disable INT - we'll poll...
+}
+
+/*****************************************************************************/
+/* In transmit we're going to send out a message                             */
+/*****************************************************************************/
+void evohome_TX(void)
+{
+  SET_STATE(STATE_TX,SUBSTATE_IDLE);
+  ccTX();
+  EIMSK &= ~_BV(CC1100_INT);                 // disable INT - we'll poll...
+
+  /***************************************************************************/
+  /* Note, the moment we enable the Tx empty interrupt the ISR will be       */
+  /* called to load the first byte.  We must therefore be sure we are ready, */
+  /* including and state transitions made before calling evohome_TX()        */
+  /***************************************************************************/
+  UCSR1B = _BV(UDRIE1)|_BV(TXEN1); // TX Empty IRQ enabled, Transmitter enable
+}
+
+/*****************************************************************************/
+/* In idle, the chip is configured, but we're not doing anything             */
+/*****************************************************************************/
+void evohome_IDLE(void)
+{
+  SET_STATE(STATE_IDLE,SUBSTATE_IDLE);
+  UCSR1B = 0;                      // Disable Tx & Rx
+  ccStrobe( CC1100_SIDLE );
+  EIMSK &= ~_BV(CC1100_INT);                 // disable INT - we'll poll...
+}
+
+/*****************************************************************************/
+/* CC1100 init, where we reset and load our CC110x config                    */
+/*****************************************************************************/
+void rf_evohome_init(void)
+{
+  SET_BIT( CC1100_CS_DDR, CC1100_CS_PIN );
+
+  CC1100_DEASSERT;                           // Toggle chip select signal
+  my_delay_us(30);
+  CC1100_ASSERT;
+  my_delay_us(30);
+  CC1100_DEASSERT;
+  my_delay_us(45);
+
+  ccStrobe( CC1100_SRES );
+  my_delay_us(100);
+
+  for (uint8_t i = 0; i < sizeof(EVOHOME_CFG_ASYNC_38400); i += 2)
+    cc1100_writeReg( pgm_read_byte(&EVOHOME_CFG_ASYNC_38400[i]),
+                     pgm_read_byte(&EVOHOME_CFG_ASYNC_38400[i+1]) );
+
+
+  ccStrobe( CC1100_SCAL );
+
+  my_delay_ms(4);
+
+  uart1_initialize();
+
+  SET_STATE(STATE_IDLE,SUBSTATE_IDLE);
+}
+
+/*****************************************************************************/
+/* Main task.  We do little here, except for unloading receive messages      */
+/*****************************************************************************/
+void
+rf_evohome_task(void)
+{
+  uint8_t m,n;
+
+  switch (state)
+  {
+    case STATE_RX:
+      {
+        if (substate == SUBSTATE_RX_DONE)
+        {
+          /*******************************************************************/
+          /* Depending on settings, generate error info                      */
+          /*******************************************************************/
+          if (debug && abort)
+          {
+            DS("v!");
+            DC(abort);
+            DC(':');
+          }
+          else
+          {
+            DS( "vr" );
+          }
+
+          for (n=0;n<msg_pos;n++)
+          {
+            m = (msg[n]>>4)&0xf;
+            DC((m < 10 ? '0'+m : 'A'+m-10));
+            m = (msg[n] & 0xf);
+            DC((m < 10 ? '0'+m : 'A'+m-10));
+          }
+          DNL();
+
+  #if 0
+          /*******************************************************************/
+          /* Consider adding a calibrate sequence before continuting.        */
+          /* However, for Evohome, you can often get two large messages sent */
+          /* one after another from a single source, so we have to be ready  */
+          /* for the next messsage ASAP.  Doing calibration here can cause   */
+          /* message loss.                                                   */
+          /*                                                                 */
+          /* Better to do periodically                                       */
+          /*******************************************************************/
+          ccStrobe( CC1100_SCAL );
+          my_delay_ms(1);
+  #endif
+          evohome_LISTEN();
+        }
+      } break;
+
+    default:
+      {
+      } break;
+  }
+};
+
+/*****************************************************************************/
+/* In the func routine we process requests from the user                     */
+/*****************************************************************************/
+void rf_evohome_func(char *in)
+{
+  switch (in[1])
+  {
+    case 'd':
+    case 'l':
+      {
+        if (in[1]=='d')
+        {
+          debug=1;
+        }
+        else
+        {
+          debug=0;
+        }
+
+        if (state==STATE_OFF)
+        {
+          rf_evohome_init();
+        }
+
+        if (state==STATE_IDLE)
+        {
+          evohome_LISTEN();
+        }
+
+        DS("va"); // Ack
+        DNL();
+
+      } break;
+
+    case 's':
+      {
+        if (state==STATE_OFF)
+        {
+          rf_evohome_init();
+        }
+
+        /*********************************************************************/
+        /* Decide if channel is free.  If not indicate busy, and allow app   */
+        /* to retry (if needed we could accept and schedule, but it will     */
+        /* require extra buffer space)                                       */
+        /*********************************************************************/
+        if ((state==STATE_IDLE) || (state==STATE_LISTEN))
+        {
+          if (state==STATE_LISTEN)
+          {
+            evohome_IDLE();
+          }
+
+          msg_len=fromhex(&in[2],(uint8_t *)msg,sizeof(msg));
+
+          /*******************************************************************/
+          /* Enable Tx, which will also lead to ISR being called to load the */
+          /* first byte                                                      */
+          /*                                                                 */
+          /* Ack now because we have committed to transmit                   */
+          /*******************************************************************/
+          evohome_TX();
+          DS("va"); // Ack
+          DNL();
+        }
+        else
+        {
+          DS("vb"); // Busy
+          DNL();
+        }
+      } break;
+
+    case 0x00:
+      {
+        /***********************************************************************/
+        /* Off                                                                 */
+        /***********************************************************************/
+        debug=0;
+        evohome_IDLE();
+        SET_STATE(STATE_OFF,SUBSTATE_IDLE);
+        DS("va"); // Ack
+        DNL();
+      } break;
+
+    default:
+      {
+        /***********************************************************************/
+        /* Unknown command                                                     */
+        /***********************************************************************/
+        DS("v?"); // NAck
+        DNL();
+
+      } break;
+  }
+}
+
+/*****************************************************************************/
+/* Program the UART, but don't yet enable Tx or Rx                           */
+/*****************************************************************************/
+void uart1_initialize(void) {
+  // initialize I/O pins
+  DDRD |= _BV( 3 ); // PD3: TX out
+
+  // initialize the USART
+  UBRR1H = UBRRH_VALUE;
+  UBRR1L = UBRRL_VALUE;
+  UCSR1A = 0;
+#if USE_2X
+  UCSR1A |= _BV(U2X1);
+#endif
+
+  UCSR1B = 0; // Tx & Rx disabled
+  UCSR1C = _BV(UCSZ10) | _BV(UCSZ11); // 8 Bit, n, 1 Stop
+}
+
+/*****************************************************************************/
+/* Transmit interrupt function                                               */
+/*                                                                           */
+/* All the transmit behaviour is driven of the data register empty interrupt.*/
+/* This ensures we get nice tight outbound messages.                         */
+/*****************************************************************************/
+ISR(USART1_UDRE_vect)
+{
+  uint8_t data;
+
+  /***************************************************************************/
+  /* Failsafe logic to protect against stray ISR                             */
+  /***************************************************************************/
+  if (state != STATE_TX)
+  {
+    evohome_LISTEN();
+  }
+  else
+  {
+    /*************************************************************************/
+    /* Get down to the business of sending data                              */
+    /*************************************************************************/
+    switch (substate)
+    {
+      case SUBSTATE_IDLE:
+      {
+        /*********************************************************************/
+        /* This is the startup case                                          */
+        /*********************************************************************/
+        msg_pos = 0;
+        SET_SUBSTATE(SUBSTATE_TX_PREAMBLE);
+
+        /*********************************************************************/
+        /* Deliberate run through into TX to send first byte                 */
+        /*********************************************************************/
+      }
+
+      case SUBSTATE_TX_PREAMBLE:
+      {
+        /*********************************************************************/
+        /* Send permable bytes                                               */
+        /*********************************************************************/
+        UDR1=preamble[msg_pos++];
+
+        if (msg_pos >= PREAMBLE_LEN)
+        {
+          SET_SUBSTATE(SUBSTATE_TX_DATA);
+          chksum=0;
+          work_index=0;
+          msg_pos=0;
+        }
+      } break;
+
+      case SUBSTATE_TX_DATA:
+      {
+        /*********************************************************************/
+        /* Encode each byte in turn                                          */
+        /*********************************************************************/
+        if (work_index==0)
+        {
+          /*******************************************************************/
+          /* Encode either a byte of data, or the checksum                   */
+          /*******************************************************************/
+          if (msg_pos < msg_len)
+          {
+            chksum+=msg[msg_pos];
+            data=msg[msg_pos];
+          }
+          else
+          {
+            data=-chksum;
+          }
+
+          work[0]=MANCHESTER_ENCODE(((data & 0xF0)>>4));
+          work[1]=MANCHESTER_ENCODE((data & 0xF));
+        }
+
+        /*********************************************************************/
+        /* Send byte                                                         */
+        /*********************************************************************/
+        UDR1=work[work_index++];
+
+        /*********************************************************************/
+        /* Next message byte                                                 */
+        /*********************************************************************/
+        if (work_index==2)
+        {
+          msg_pos++;
+          work_index=0;
+
+          /*******************************************************************/
+          /* If we're at the end move to postamble                           */
+          /*******************************************************************/
+          if (msg_pos > msg_len)
+          {
+            SET_SUBSTATE(SUBSTATE_TX_POSTAMBLE);
+            msg_pos=0;
+          }
+        }
+      } break;
+
+      case SUBSTATE_TX_POSTAMBLE:
+      {
+        /*********************************************************************/
+        /* Only test for postamble done _AFTER_ last byte has gone           */
+        /*********************************************************************/
+        if (msg_pos >= POSTAMBLE_LEN)
+        {
+          /*******************************************************************/
+          /* Once we're done, move back to listen state, which will disable  */
+          /* the Tx empty int.  (We used to move to TX_DONE so task routine  */
+          /* could generate ack, but we now do this when we commit to        */
+          /* transmit.)                                                      */
+          /*******************************************************************/
+          evohome_LISTEN();
+          msg_pos=0;
+        }
+        else
+        {
+          /*******************************************************************/
+          /* Send postamble bytes                                            */
+          /*******************************************************************/
+          UDR1=postamble[msg_pos++];
+        }
+
+      } break;
+
+      default:
+      {
+        /*********************************************************************/
+        /* We should never get here.  If we do, drop back to listen          */
+        /*********************************************************************/
+        evohome_LISTEN();
+      } break;
+    }
+  }
+
+}
+
+/*****************************************************************************/
+/* The bulk of the receive work is done in the Rx ISR, but using the USART   */
+/* actually means there is very little to do beyond looking for message      */
+/* boundaries and decoding                                                   */
+/*****************************************************************************/
+ISR(USART1_RX_vect) {
+
+  uint8_t errors = UCSR1A;
+  uint8_t data   = UDR1;
+  uint8_t nib1,nib2;
+
+
+  /***************************************************************************/
+  /* We are willing to consider data if we are looking for preamble or if    */
+  /* we're working on a message                                              */
+  /***************************************************************************/
+  if ((state == STATE_LISTEN) ||
+      ((state == STATE_RX) && (substate != SUBSTATE_RX_DONE)))
+  {
+    /***************************************************************************/
+    /* Error cause an abort                                                    */
+    /***************************************************************************/
+    if (errors & (_BV(FE1)|_BV(DOR1)))
+    {
+      if (state == STATE_RX)
+      {
+        if (substate > SUBSTATE_RX_PREAMBLE)
+        {
+          if (errors & _BV(FE1))
+          {
+            /*****************************************************************/
+            /* Abort indicating framing error                                */
+            /*****************************************************************/
+            RX_ABORT('F');
+          }
+          else
+          {
+            /*****************************************************************/
+            /* Abort indicating overrun                                      */
+            /*****************************************************************/
+            RX_ABORT('O');
+          }
+        }
+        else
+        {
+          SET_STATE(STATE_LISTEN,SUBSTATE_IDLE);
+        }
+      }
+    }
+    else
+    {
+      switch (substate)
+      {
+        case SUBSTATE_IDLE:
+        {
+          /*********************************************************************/
+          /* In this state we are looking for first pre-amble byte             */
+          /*********************************************************************/
+          msg_pos = MATCH_OFFSET;
+          if (data==preamble[msg_pos])
+          {
+            SET_STATE(STATE_RX, SUBSTATE_RX_PREAMBLE);
+            abort=0;
+            msg_pos++;
+          }
+        } break;
+
+        case SUBSTATE_RX_PREAMBLE:
+        {
+          /*********************************************************************/
+          /* We're looking to either complete preamble or abandon              */
+          /*********************************************************************/
+          if (msg_pos < PREAMBLE_LEN)
+          {
+            if (data==preamble[msg_pos])
+            {
+              msg_pos++;
+            }
+            else
+            {
+              SET_STATE(STATE_LISTEN,SUBSTATE_IDLE);
+            }
+          }
+
+          /*********************************************************************/
+          /* If preamble is complete, then move to Rx                          */
+          /*********************************************************************/
+          if (msg_pos == PREAMBLE_LEN)
+          {
+            SET_SUBSTATE(SUBSTATE_RX_DATA);
+            msg_pos=0;
+            work_index=0;
+            chksum=0;
+          }
+        } break;
+
+        case SUBSTATE_RX_DATA:
+        {
+          /**********************************************************************/
+          /* Abort if message is over length                                    */
+          /**********************************************************************/
+          if (msg_pos >= MAX_EVOHOME_MSG)
+          {
+            /*****************************************************************/
+            /* Abort indicating long message                                 */
+            /*****************************************************************/
+            RX_ABORT('L');
+          }
+          else
+          {
+            /*********************************************************************/
+            /* Accumulate 2 work bytes                                           */
+            /*********************************************************************/
+            work[work_index++]=data;
+
+            /*******************************************************************/
+            /* Check for normal end                                            */
+            /*******************************************************************/
+            if (data == postamble[0])
+            {
+              /*****************************************************************/
+              /* Check we've got at least one data byte, then check checksum   */
+              /*****************************************************************/
+              if ((msg_pos < 2) || chksum)
+              {
+                /*************************************************************/
+                /* Abort indicating checksum problem                         */
+                /*************************************************************/
+                RX_ABORT('C');
+              }
+              else
+              {
+                /*************************************************************/
+                /* Remove checksum byte and mark as done                     */
+                /*************************************************************/
+                msg_pos--;
+                SET_SUBSTATE(SUBSTATE_RX_DONE);
+              }
+            }
+            else if (work_index==2)
+            {
+              work_index=0;
+
+              /**********************************************************************/
+              /* Decode next character                                              */
+              /**********************************************************************/
+              nib1=MANCHESTER_DECODE(work[0]);
+              nib2=MANCHESTER_DECODE(work[1]);
+
+              /**********************************************************************/
+              /* Check for violations                                               */
+              /**********************************************************************/
+              if ((nib1==0xFF) || (nib2==0xFF))
+              {
+                /***************************************************************/
+                /* Abort indicating manchester error                           */
+                /***************************************************************/
+                RX_ABORT('M');
+              }
+              else
+              {
+                /********************************************************************/
+                /* Form message byte & save                                         */
+                /********************************************************************/
+                msg[msg_pos]=((nib1<<4) | nib2);
+                chksum+=msg[msg_pos];
+                msg_pos++;
+              }
+            }
+          }
+        } break;
+
+        case SUBSTATE_RX_DONE:
+        default:
+        {
+          /*********************************************************************/
+          /* Wait for message to completed message to be unloaded              */
+          /*                                                                   */
+          /* Any received data will either be noise or early preamble which we */
+          /* can afford to miss                                                */
+          /*********************************************************************/
+        } break;
+      }
+    }
+  }
+}
+
+#endif
diff -uarN culfw-1.66/clib/rf_evohome.h culfw-1.67/clib/rf_evohome.h
--- culfw-1.66/clib/rf_evohome.h	1970-01-01 01:00:00.000000000 +0100
+++ culfw-1.67/clib/rf_evohome.h	2017-09-07 15:38:51.000000000 +0200
@@ -0,0 +1,8 @@
+#ifndef _RF_EVOHOME_H
+#define _RF_EVOHOME_H
+
+extern uint8_t evohome_on;
+void rf_evohome_task(void);
+void rf_evohome_func(char *in);
+
+#endif
diff -uarN culfw-1.66/clib/rf_receive.c culfw-1.67/clib/rf_receive.c
--- culfw-1.66/clib/rf_receive.c	2016-03-20 19:39:40.000000000 +0100
+++ culfw-1.67/clib/rf_receive.c	2017-09-07 15:38:51.000000000 +0200
@@ -389,6 +389,7 @@
   return 1;
 }
 #endif
+
 #ifdef HAS_IT
 uint8_t analyze_it(bucket_t *b)
 {
@@ -401,6 +402,7 @@
   return 1;
 }
 #endif
+
 #ifdef HAS_TCM97001
 uint8_t analyze_tcm97001(bucket_t *b)
 {
@@ -414,6 +416,7 @@
   return 1;
 }
 #endif
+
 #ifdef HAS_REVOLT
 uint8_t analyze_revolt(bucket_t *b)
 {
@@ -462,6 +465,7 @@
   bucket_t *b;
 
   if(lowtime) {
+#ifndef NO_RF_DEBUG
     if(tx_report & REP_LCDMON) {
 #ifdef HAS_LCD
       lcd_txmon(hightime, lowtime);
@@ -481,6 +485,7 @@
       DC('r'); if(tx_report & REP_BINTIME) DC(hightime);
       DC('f'); if(tx_report & REP_BINTIME) DC(lowtime);
     }
+#endif // NO_RF_DEBUG
     lowtime = 0;
   }
 
@@ -627,6 +632,7 @@
 
   }
 
+#ifndef NO_RF_DEBUG
   if(tx_report & REP_BITS) {
 
     DC('p');
@@ -651,6 +657,7 @@
     DNL();
 
   }
+#endif
 
   b->state = STATE_RESET;
   bucket_nrused--;
@@ -691,8 +698,10 @@
   OCR1A = TWRAP;                        // Wrap Timer
   TCNT1=tmp;                            // reinitialize timer to measure times > SILENCE
 #endif
+#ifndef NO_RF_DEBUG
   if(tx_report & REP_MONITOR)
     DC('.');
+#endif
 
   if(bucket_array[bucket_in].state < STATE_COLLECT ||
      bucket_array[bucket_in].byteidx < 2) {    // false alarm
@@ -703,8 +712,10 @@
 
   if(bucket_nrused+1 == RCV_BUCKETS) {   // each bucket is full: reuse the last
 
+#ifndef NO_RF_DEBUG
     if(tx_report & REP_BITS)
       DS_P(PSTR("BOVF\r\n"));            // Bucket overflow
+#endif
 
     reset_input();
 
diff -uarN culfw-1.66/clib/rf_router.c culfw-1.67/clib/rf_router.c
--- culfw-1.66/clib/rf_router.c	2012-07-22 11:07:31.000000000 +0200
+++ culfw-1.67/clib/rf_router.c	2017-09-07 15:38:51.000000000 +0200
@@ -30,6 +30,9 @@
 #ifdef RFR_DEBUG
 uint16_t nr_t, nr_f, nr_e, nr_k, nr_h, nr_r, nr_plus;
 #endif
+#ifdef RFR_FILTER
+uint8_t filter[6];
+#endif
 #undef RFR_USBECHO
 
 
@@ -51,6 +54,9 @@
     tx_report = 0x21;
     set_txrestore();
   }
+#ifdef RFR_FILTER
+  filter[0] = 0;
+#endif
 }
 
 void
@@ -76,6 +82,16 @@
     DNL();
 #endif
 
+#ifdef RFR_FILTER
+  } else if(in[1] == 'f') {      // uiXXYY: set own id to XX and router id to YY
+    uint8_t i=0;
+    while(i < (sizeof(filter)-1) && in[i+2]) {
+      filter[i] = in[i+2];
+      i++;
+    }
+    filter[i] = 0;
+#endif
+
   } else if(in[1] == 'i') {      // uiXXYY: set own id to XX and router id to YY
     fromhex(in+2, &rf_router_myid, 1);
     ewb(EE_RF_ROUTER_ID, rf_router_myid);
@@ -122,14 +138,25 @@
 rf_router_send(uint8_t addAddr)
 {
 #ifdef RFR_DEBUG
-       if(RFR_Buffer.buf[5] == 'T') nr_t++;
-  else if(RFR_Buffer.buf[5] == 'F') nr_f++;
-  else if(RFR_Buffer.buf[5] == 'E') nr_e++;
-  else if(RFR_Buffer.buf[5] == 'K') nr_k++;
-  else if(RFR_Buffer.buf[5] == 'H') nr_h++;
+       if(RFR_Buffer.buf[0] == 'T') nr_t++;
+  else if(RFR_Buffer.buf[0] == 'F') nr_f++;
+  else if(RFR_Buffer.buf[0] == 'E') nr_e++;
+  else if(RFR_Buffer.buf[0] == 'K') nr_k++;
+  else if(RFR_Buffer.buf[0] == 'H') nr_h++;
   else                              nr_r++;
 #endif
 
+#ifdef RFR_FILTER
+  uint8_t i;
+  for(i=0; filter[i]; i++)
+    if(RFR_Buffer.buf[0] == filter[i])
+      break;
+  if(i > 0 && filter[i] == 0) { // not found
+    rb_reset(&RFR_Buffer);
+    return;
+  }
+#endif
+
   uint8_t buf[7], l = 1;
   buf[0] = RF_ROUTER_PROTO_ID;
   if(addAddr) {
diff -uarN culfw-1.66/clib/rf_send.c culfw-1.67/clib/rf_send.c
--- culfw-1.66/clib/rf_send.c	2015-05-01 14:00:35.000000000 +0200
+++ culfw-1.67/clib/rf_send.c	2017-09-07 15:38:51.000000000 +0200
@@ -44,55 +44,63 @@
 #define EM_ONE         800     //   800uS
 #define EM_ZERO        400     //   400uS
 
-uint16_t credit_10ms;
-
-#ifdef HAS_RAWSEND
+#if defined(HAS_HOERMANN_SEND)
+#define HRM_ZERO_H         992 //us
+#define HRM_ZERO_L         448 //us
+#define HRM_ONE_H          528 //us
+#define HRM_ONE_L          928 //us
+#define HRM_EXTRA_SYNC_H  4000 //us  measured with CUL raw read output
+#define HRM_EXTRA_SYNC_L   600 //us  measured with CUL raw read output
+#endif
 
-#define MAX_SNDMSG 12
-#define MAX_SNDRAW 12
+uint16_t credit_10ms;
 
-static uint8_t zerohigh, zerolow, onehigh, onelow;
 #define TMUL(x) (x<<4)
 #define TDIV(x) (x>>4)
 
-static void
-send_bit(uint8_t bit)
-{
-  CC1100_OUT_PORT |= _BV(CC1100_OUT_PIN);         // High
-  my_delay_us(bit ? TMUL(onehigh) : TMUL(zerohigh));
 
-  CC1100_OUT_PORT &= ~_BV(CC1100_OUT_PIN);       // Low
-  my_delay_us(bit ? TMUL(onelow) : TMUL(zerolow));
-}
+#if defined(HAS_RAWSEND) || defined(HAS_HOERMANN_SEND)
+
+#  define MAX_SNDMSG 12
+#  define MAX_SNDRAW 12
+
+  static uint8_t zerohigh, zerolow, onehigh, onelow;
+
+  static void
+  send_bit(uint8_t bit)
+  {
+    CC1100_OUT_PORT |= _BV(CC1100_OUT_PIN);         // High
+    my_delay_us(bit ? TMUL(onehigh) : TMUL(zerohigh));
+
+    CC1100_OUT_PORT &= ~_BV(CC1100_OUT_PIN);       // Low
+    my_delay_us(bit ? TMUL(onelow) : TMUL(zerolow));
+  }
 
 #else
 
-#define MAX_SNDMSG 6    // FS20: 4 or 5 + CRC, FHT: 5+CRC
-#define MAX_SNDRAW 7    // MAX_SNDMSG*9/8 (parity bit)
+#  define MAX_SNDMSG 6    // FS20: 4 or 5 + CRC, FHT: 5+CRC
+#  define MAX_SNDRAW 7    // MAX_SNDMSG*9/8 (parity bit)
 
-static void
-send_bit(uint8_t bit)
-{
-  CC1100_OUT_PORT |= _BV(CC1100_OUT_PIN);         // High
-  my_delay_us(bit ? FS20_ONE : FS20_ZERO);
+  static void
+  send_bit(uint8_t bit)
+  {
+    CC1100_OUT_PORT |= _BV(CC1100_OUT_PIN);         // High
+    my_delay_us(bit ? FS20_ONE : FS20_ZERO);
 
-  CC1100_OUT_PORT &= ~_BV(CC1100_OUT_PIN);       // Low
-  my_delay_us(bit ? FS20_ONE : FS20_ZERO);
-}
+    CC1100_OUT_PORT &= ~_BV(CC1100_OUT_PIN);       // Low
+    my_delay_us(bit ? FS20_ONE : FS20_ZERO);
+  }
 
 #endif
 
-static void sendraw(uint8_t *msg, uint8_t sync, uint8_t nbyte, uint8_t bitoff, 
-                uint8_t repeat, uint8_t pause);
-
 // msg is with parity/checksum already added
 static void
 sendraw(uint8_t *msg, uint8_t sync, uint8_t nbyte, uint8_t bitoff,
-                uint8_t repeat, uint8_t pause)
+                uint8_t repeat, uint8_t pause, uint8_t addH, uint8_t addL)
 {
   // 12*800+1200+nbyte*(8*1000)+(bits*1000)+800+10000 
   // message len is < (nbyte+2)*repeat in 10ms units.
-  int8_t i, j, sum = (nbyte+2)*repeat;
+  int8_t i, j, sum = (nbyte+2)*repeat + addH + addL;
   if (credit_10ms < sum) {
     DS_P(PSTR("LOVF\r\n"));
     return;
@@ -118,6 +126,15 @@
     set_ccon();
   ccTX();                                       // Enable TX 
   do {
+
+    if(addH>0 || addL>0) {
+      CC1100_OUT_PORT |= _BV(CC1100_OUT_PIN);        // High
+      my_delay_us(TMUL(addH));
+
+      CC1100_OUT_PORT &= ~_BV(CC1100_OUT_PIN);       // Low
+      my_delay_us(TMUL(addL));
+    }
+
     for(i = 0; i < sync; i++)                   // sync
       send_bit(0);
     if(sync)
@@ -193,11 +210,11 @@
     oby++; obi = 7;
   }
 
-#ifdef HAS_RAWSEND
+#if defined(HAS_RAWSEND) || defined(HAS_HOERMANN_SEND)
   zerohigh = zerolow = TDIV(FS20_ZERO);
   onehigh = onelow = TDIV(FS20_ONE);
 #endif
-  sendraw(obuf, 12, oby, obi, repeat, FS20_PAUSE);
+  sendraw(obuf, 12, oby, obi, repeat, FS20_PAUSE, 0, 0);
 }
 
 void
@@ -213,12 +230,12 @@
 fs20send(char *in)
 {
 #ifdef HAS_DMX
-  if (dmx_fs20_emu( in ))
-	return;
+  if(dmx_fs20_emu( in ))
+    return;
 #endif
 #ifdef HAS_HELIOS
   if (helios_fs20_emu( in ))
-	return;
+    return;
 #endif
   addParityAndSend(in, 6, 3);
 }
@@ -243,7 +260,7 @@
   zerolow  = hb[4];
   onehigh  = hb[5];
   onelow   = hb[6];
-  sendraw(hb+7, sync, nby, nbi, repeat, pause);
+  sendraw(hb+7, sync, nby, nbi, repeat, pause, 0, 0);
 }
 
 
@@ -286,7 +303,7 @@
     oby++; obi = 7;
   }
 
-  sendraw(obuf, 12, oby, obi, 3, FS20_PAUSE);
+  sendraw(obuf, 12, oby, obi, 3, FS20_PAUSE, 0, 0);
 }
 
 void
@@ -333,7 +350,7 @@
     iby++;
   }
 
-  sendraw(obuf, 10, oby, obi, 3, FS20_PAUSE);
+  sendraw(obuf, 10, oby, obi, 3, FS20_PAUSE, 0, 0);
 }
 
 #endif
@@ -353,6 +370,24 @@
   onehigh  = TDIV(540);
   onelow   = TDIV(1700);
   hb[3] = 0x80;     //10000000
-  sendraw(hb, 0, 3, 6, 3, 15);
+  sendraw(hb, 0, 3, 6, 3, 15, 0, 0);
+}
+#endif
+
+#ifdef HAS_HOERMANN_SEND
+void
+hm_send(char *in)
+{
+  uint8_t hb[MAX_SNDMSG];
+  uint8_t hblen = fromhex(in + 2, hb, MAX_SNDMSG - 1);
+
+  if(hblen != 5)       // LENERR
+    return;
+  zerohigh = TDIV(HRM_ZERO_H);
+  zerolow = TDIV(HRM_ZERO_L);
+  onehigh = TDIV(HRM_ONE_H);
+  onelow = TDIV(HRM_ONE_L);
+
+  sendraw(hb, 8, 4, 4, 5, 0, TDIV(HRM_EXTRA_SYNC_H), TDIV(HRM_EXTRA_SYNC_L));
 }
 #endif
diff -uarN culfw-1.66/clib/rf_send.h culfw-1.67/clib/rf_send.h
--- culfw-1.66/clib/rf_send.h	2015-02-19 09:25:53.000000000 +0100
+++ culfw-1.67/clib/rf_send.h	2017-09-07 15:38:51.000000000 +0200
@@ -8,6 +8,7 @@
 void em_send(char *in);
 void ks_send(char *in);
 void ur_send(char *in);
+void hm_send(char *in);
 void addParityAndSend(char *in, uint8_t startcs, uint8_t repeat);
 void addParityAndSendData(uint8_t *hb, uint8_t hblen,
                         uint8_t startcs, uint8_t repeat);
diff -uarN culfw-1.66/clib/rf_zwave.c culfw-1.67/clib/rf_zwave.c
--- culfw-1.66/clib/rf_zwave.c	2016-03-06 11:54:12.000000000 +0100
+++ culfw-1.67/clib/rf_zwave.c	2017-09-07 15:38:51.000000000 +0200
@@ -8,7 +8,11 @@
 #include "rf_zwave.h"
 #include "cc1100.h"
 
-#define MAX_ZWAVE_MSG 64
+#ifdef CUL_V4
+#define MAX_ZWAVE_MSG 64        // 1024k SRAM is not enough: no SEC for CUL_V4
+#else
+#define MAX_ZWAVE_MSG (8+158+2) // 158 == aMacMaxMSDUSizeR3 (G.9959)
+#endif
 
 void zwave_doSend(uint8_t *msg, uint8_t hblen);
 
diff -uarN culfw-1.66/clib/stacking.c culfw-1.67/clib/stacking.c
--- culfw-1.66/clib/stacking.c	2014-03-17 15:50:20.000000000 +0100
+++ culfw-1.67/clib/stacking.c	2017-09-07 15:38:51.000000000 +0200
@@ -25,7 +25,7 @@
 #define USE_2X
 #include <util/setbaud.h>
 
-static char mycmd[256];
+static char mycmd[256];  /* TODO: are 256 byte enough for EnOcean communication? */
 static uint8_t mypos = 0;
 static volatile uint8_t myEOL = 0;
 
@@ -47,6 +47,238 @@
   myEOL = 0;
 }
 
+#ifdef HAS_STACK_ENOCEAN
+#include <ctype.h>
+static uint8_t enocean_connected = 0;
+void uart_57600(void) {
+#undef  BAUD  // avoid compiler warning
+#undef  BAUD_TOL
+#define BAUD 57600
+#define BAUD_TOL 3  /* TODO: is 3% tolerance ok? */
+#include <util/setbaud.h>
+  UBRR1H = UBRRH_VALUE;
+  UBRR1L = UBRRL_VALUE;
+#if USE_2X
+  UCSR1A |= _BV(U2X1);
+#else
+  UCSR1A &= ~_BV(U2X1);
+#endif
+}
+
+enum {
+    STATE_WAIT_SYNC = 0,
+    STATE_WAIT_DATA_LENGTH_H,
+    STATE_WAIT_DATA_LENGTH_L,
+    STATE_WAIT_OPTIONAL_LENGTH,
+    STATE_WAIT_PACKET_TYPE,
+    STATE_WAIT_CRC,
+    STATE_WAIT_END
+};
+static uint8_t state           = STATE_WAIT_SYNC;
+static uint8_t data_length_h   = 0;
+static uint8_t data_length_l   = 0;
+static uint8_t optional_length = 0;
+static uint8_t packet_type     = 0;
+static uint8_t crc             = 0;
+static uint8_t len             = 0;
+static uint16_t packet_size    = 0;
+
+/* From EnOcean Serial Protocol 3 (ESP3) V1.15 / Feb 28, 2011,
+ * chapter 2.3 CRC8 calculation
+ */
+uint8_t u8CRC8Table[256] = {
+  0x00, 0x07, 0x0e, 0x09, 0x1c, 0x1b, 0x12, 0x15,
+  0x38, 0x3f, 0x36, 0x31, 0x24, 0x23, 0x2a, 0x2d,
+  0x70, 0x77, 0x7e, 0x79, 0x6c, 0x6b, 0x62, 0x65,
+  0x48, 0x4f, 0x46, 0x41, 0x54, 0x53, 0x5a, 0x5d,
+  0xe0, 0xe7, 0xee, 0xe9, 0xfc, 0xfb, 0xf2, 0xf5,
+  0xd8, 0xdf, 0xd6, 0xd1, 0xc4, 0xc3, 0xca, 0xcd,
+  0x90, 0x97, 0x9e, 0x99, 0x8c, 0x8b, 0x82, 0x85,
+  0xa8, 0xaf, 0xa6, 0xa1, 0xb4, 0xb3, 0xba, 0xbd,
+  0xc7, 0xc0, 0xc9, 0xce, 0xdb, 0xdc, 0xd5, 0xd2,
+  0xff, 0xf8, 0xf1, 0xf6, 0xe3, 0xe4, 0xed, 0xea,
+  0xb7, 0xb0, 0xb9, 0xbe, 0xab, 0xac, 0xa5, 0xa2,
+  0x8f, 0x88, 0x81, 0x86, 0x93, 0x94, 0x9d, 0x9a,
+  0x27, 0x20, 0x29, 0x2e, 0x3b, 0x3c, 0x35, 0x32,
+  0x1f, 0x18, 0x11, 0x16, 0x03, 0x04, 0x0d, 0x0a,
+  0x57, 0x50, 0x59, 0x5e, 0x4b, 0x4c, 0x45, 0x42,
+  0x6f, 0x68, 0x61, 0x66, 0x73, 0x74, 0x7d, 0x7a,
+  0x89, 0x8e, 0x87, 0x80, 0x95, 0x92, 0x9b, 0x9c,
+  0xb1, 0xb6, 0xbf, 0xb8, 0xad, 0xaa, 0xa3, 0xa4,
+  0xf9, 0xfe, 0xf7, 0xf0, 0xe5, 0xe2, 0xeb, 0xec,
+  0xc1, 0xc6, 0xcf, 0xc8, 0xdd, 0xda, 0xd3, 0xd4,
+  0x69, 0x6e, 0x67, 0x60, 0x75, 0x72, 0x7b, 0x7c,
+  0x51, 0x56, 0x5f, 0x58, 0x4d, 0x4a, 0x43, 0x44,
+  0x19, 0x1e, 0x17, 0x10, 0x05, 0x02, 0x0b, 0x0c,
+  0x21, 0x26, 0x2f, 0x28, 0x3d, 0x3a, 0x33, 0x34,
+  0x4e, 0x49, 0x40, 0x47, 0x52, 0x55, 0x5c, 0x5b,
+  0x76, 0x71, 0x78, 0x7f, 0x6A, 0x6d, 0x64, 0x63,
+  0x3e, 0x39, 0x30, 0x37, 0x22, 0x25, 0x2c, 0x2b,
+  0x06, 0x01, 0x08, 0x0f, 0x1a, 0x1d, 0x14, 0x13,
+  0xae, 0xa9, 0xa0, 0xa7, 0xb2, 0xb5, 0xbc, 0xbb,
+  0x96, 0x91, 0x98, 0x9f, 0x8a, 0x8D, 0x84, 0x83,
+  0xde, 0xd9, 0xd0, 0xd7, 0xc2, 0xc5, 0xcc, 0xcb,
+  0xe6, 0xe1, 0xe8, 0xef, 0xfa, 0xfd, 0xf4, 0xf3
+};
+#define proccrc8(u8CRC, u8Data) (u8CRC8Table[u8CRC ^ u8Data])
+uint8_t crc_ok(void) {
+  uint8_t u8CRC = 0;
+  u8CRC = proccrc8(u8CRC, data_length_h);
+  u8CRC = proccrc8(u8CRC, data_length_l);
+  u8CRC = proccrc8(u8CRC, optional_length);
+  u8CRC = proccrc8(u8CRC, packet_type);
+
+  return u8CRC == crc;
+}
+
+uint8_t asc2int(uint8_t c) {
+    c = toupper(c)-'0';
+    return (c<10 ? c : c-7);
+}
+uint8_t int2asc(uint8_t i) {
+    return (i<10 ? '0'+i : 'A'+i-10);
+}
+void put_in_mycmd(uint8_t b) {
+  mycmd[mypos++] = int2asc((b>>4) & 0x0F);
+  mycmd[mypos++] = int2asc(b & 0x0F);
+}
+
+/* Receive data from EnOcean Pi in binary format */
+/* The packet structure has to be analyzed to find the packet start */
+ISR(USART1_RX_vect) {
+  uint8_t errors = UCSR1A;
+  uint8_t data   = UDR1;
+
+  if (errors & (_BV(FE1)|_BV(DOR1)))
+	return;
+
+  if (myEOL) // unprocessed message?
+    return;
+
+  if (enocean_connected == 1) 
+  {
+    switch (state)
+    {
+      case STATE_WAIT_SYNC:
+        if (data == 0x55)
+          state = STATE_WAIT_DATA_LENGTH_H;
+        break;
+      case STATE_WAIT_DATA_LENGTH_H:
+        data_length_h = data;
+        state = STATE_WAIT_DATA_LENGTH_L;
+        break;
+      case STATE_WAIT_DATA_LENGTH_L:
+        data_length_l = data;
+        state = STATE_WAIT_OPTIONAL_LENGTH;
+        break;
+      case STATE_WAIT_OPTIONAL_LENGTH:
+        optional_length = data;
+        state = STATE_WAIT_PACKET_TYPE;
+        break;
+      case STATE_WAIT_PACKET_TYPE:
+        packet_type = data;
+        state = STATE_WAIT_CRC;
+        break;
+      case STATE_WAIT_CRC:
+        crc = data;
+        if (crc_ok()) {
+          mypos = 0;
+          put_in_mycmd(0x55);
+          put_in_mycmd(data_length_h);
+          put_in_mycmd(data_length_l);
+          put_in_mycmd(optional_length);
+          put_in_mycmd(packet_type);
+          put_in_mycmd(crc);
+          len = 0;
+          packet_size = (((uint16_t)data_length_h)<<8) + data_length_l + optional_length;
+          state = STATE_WAIT_END;
+        }
+        else {
+          /* sync byte might be in data_length_h, data_length_l, 
+           * optional_length, packet_type or crc */
+          if (data_length_h == 0x55) {
+            data_length_h   = data_length_l;
+            data_length_l   = optional_length;
+            optional_length = packet_type;
+            packet_type     = crc;
+            state = STATE_WAIT_CRC;
+          }
+          else if (data_length_l == 0x55) {
+            data_length_h   = optional_length;
+            data_length_l   = packet_type;
+            optional_length = crc;
+            state = STATE_WAIT_PACKET_TYPE;
+          }
+          else if (optional_length == 0x55) {
+            data_length_h = packet_type;
+            data_length_l = crc;
+            state = STATE_WAIT_OPTIONAL_LENGTH;
+          }
+          else if (packet_type == 0x55) {
+            data_length_h     = crc;
+            state = STATE_WAIT_DATA_LENGTH_L;
+          }
+          else if (crc == 0x55) {
+            state = STATE_WAIT_DATA_LENGTH_H;
+          }
+          else {
+            state = STATE_WAIT_SYNC;
+          }
+        }
+        break;
+      case STATE_WAIT_END:
+        put_in_mycmd(data);
+        ++len;
+        if (len >= packet_size+1)
+        {
+          
+          mycmd[mypos] = 0;
+          myEOL = 1; 
+          state = STATE_WAIT_SYNC;
+        }
+        break;
+    }
+  }
+  else
+  {
+    if (data == 13)
+      return;
+
+    if (data == 10) {
+      // EOL
+      mycmd[mypos] = 0;
+      myEOL = 1; 
+      return;
+    }
+
+    mycmd[mypos++] = data;
+  }
+}
+
+void stacking_func_eno(char* in) { 
+  // downlink message to UART1 by removing one '*'
+  uint8_t i = 1;
+  uint8_t high = 0;
+  uint8_t low = 0;
+  
+  if (enocean_connected == 0) 
+  {
+    uart_57600();
+    enocean_connected = 1;
+  }
+
+  while (in[i]) { 
+    while(!(UCSR1A&_BV(UDRE1))) ; // wait for UART1 clear
+    
+    /* Two ASCII characters give one byte */
+    high = asc2int(in[i++]);
+    if (in[i]) {
+      low  = asc2int(in[i++]);
+    }
+    UDR1 = (high<<4) | low;
+  }
+}
+#else
 ISR(USART1_RX_vect) {
   uint8_t errors = UCSR1A;
   uint8_t data   = UDR1;
@@ -69,6 +301,7 @@
 
   mycmd[mypos++] = data;
 }
+#endif
 
 void stacking_task(void) {
   if (!myEOL)
diff -uarN culfw-1.66/clib/stacking.h culfw-1.67/clib/stacking.h
--- culfw-1.66/clib/stacking.h	2014-03-17 15:50:20.000000000 +0100
+++ culfw-1.67/clib/stacking.h	2017-09-07 15:38:51.000000000 +0200
@@ -10,5 +10,6 @@
 void stacking_initialize(void);
 void stacking_task(void);
 void stacking_func(char*);
+void stacking_func_eno(char*);
 
 #endif
diff -uarN culfw-1.66/clib/ttydata.c culfw-1.67/clib/ttydata.c
--- culfw-1.66/clib/ttydata.c	2014-03-17 15:45:53.000000000 +0100
+++ culfw-1.67/clib/ttydata.c	2017-09-07 15:38:51.000000000 +0200
@@ -32,7 +32,7 @@
 void
 analyze_ttydata(uint8_t channel)
 {
-  static uint8_t cmdlen;
+  static int cmdlen;  /* we need int because TTY_BUFSIZE may be >255 */
   uint8_t ucCommand;
   uint8_t odc = display_channel;
   display_channel = channel;
diff -uarN culfw-1.66/docs/commandref.html culfw-1.67/docs/commandref.html
--- culfw-1.66/docs/commandref.html	2015-04-24 23:47:35.000000000 +0200
+++ culfw-1.67/docs/commandref.html	2017-09-07 15:38:52.000000000 +0200
@@ -63,6 +63,7 @@
     <a href="#cmd_U">U</a>
     <a href="#cmd_u">u</a>
     <a href="#cmd_V">V</a>
+    <a href="#cmd_v">v</a>
     <a href="#cmd_W">W</a>
     <a href="#cmd_w">w</a>
     <a href="#cmd_X">X</a>
@@ -888,6 +889,45 @@
       Print the hardware version on CUL_V3 and CUL_V4
     </ul><br><br>
 
+    <a name="cmd_v"></a>
+    v&lt;func&gt;[&lt;hex&gt;]
+    <ul>
+      Honeywell EvoHome/EvoTouch mode.
+      <br>
+      <br>
+      &lt;func&gt; is one of:
+      <ul>
+      <li> l<br>
+        Listen for EvoHome messages.<br>
+        Only EvoHome messages with a valid checksum will be returned in this mode.<br>
+        Messages are reported on receipt as vr&lt;hex&gt; with the valid checksum byte removed.
+      <li> d<br>
+        Listen for EvoHome messages as above, but also report aborted receives as v!&lt;code&gt;[&lt;hex&gt;].<br>
+        This extra information can be useful for debug purpose.<br>
+        Codes include:<br><br>
+        <ul>
+        Interference related<br>
+        <li> F - Framing error, where received data doesn't decode to 1start-8data-1stop at 38,400bps
+        <li> M - Manchester coding error in received data
+        <li> C - Checksum error over completed message<br><br>
+        Firmware problem
+        <li> L - Message exceed expected maximum length<br>
+        <li> O - Overrun, where a second data byte arrived before the ISR processing the first was able to complete
+      </ul>
+      <li> s&lt;hex&gt;<br>
+        Send out an EvoHome message.  No checking is performed on sent data, but a valid checksum
+        is automatically added.
+      <li> <br>
+        Disable EvoHome reception.
+      </ul>
+      <br>
+      Responses<br>
+      <ul>
+      <li>va - Successful acknowledgement to request
+      <li>vb - Attempt to send whilst device busy receiving a message (small timing window, just retry)
+      <li>v? - Unknown command
+      </ul>
+    </ul><br><br>
 
     <a name="cmd_W"></a>
     W&lt;AA&gt;&lt;DD&gt; or W&lt;AAAA&gt;&lt;DD&gt;
diff -uarN culfw-1.66/docs/culfw.html culfw-1.67/docs/culfw.html
--- culfw-1.66/docs/culfw.html	2014-12-04 23:05:44.000000000 +0100
+++ culfw-1.67/docs/culfw.html	2017-09-07 15:40:18.000000000 +0200
@@ -43,8 +43,8 @@
       culfw is a GPL'd firmware for the <a
       href="http://shop.busware.de/advanced_search_result.php?keywords=CUL">CUL</a>
       family of devices.<br><br>
-      Current Version: (as of 2014-06-28) is <a
-      href="http://culfw.de/culfw-1.61.tar.gz">1.61</a>.
+      Current Version: (as of 2017-09-07) is <a
+      href="http://culfw.de/culfw-1.67.tar.gz">1.67</a>.
       See the <a href="CHANGED">CHANGED</a> file for current changes.<br>
       <br>
 
@@ -160,9 +160,10 @@
         pressing the micro-switch.</li>
 
       <li>CUL/CUN @ Windows:<br>
-        See also <a href="http://groups.google.com/group/cul-fans/web/get-cul-running--windows">this</a>
-        link for details. Do no install any drivers. Get the Windows Flash
-        tool "FLIP" from Atmel, start it, detect the CUL and flash the file
+        See also <a
+        href="https://wiki.fhem.de/wiki/Windows_-_FHEM_installieren#Hardware_bestellen">this</a>
+        link for details (german). Do no install any drivers. Get the Windows
+        Flash tool "FLIP" from Atmel, start it, detect the CUL and flash the file
         CUL.hex to it.</li>
 
       <li>CUNO:<br>
@@ -206,14 +207,14 @@
     <ul>
       Hardware: <a href="http://www.busware.de">http://www.busware.de</a><br>
       Source (and compiled firmware): <a
-            href="http://culfw.de/culfw-1.61.tar.gz">
-            http://culfw.de/culfw-1.61.tar.gz</a><br>
+            href="http://culfw.de/culfw-1.67.tar.gz">
+            http://culfw.de/culfw-1.67.tar.gz</a><br>
       FAQ: <a href="http://culfw.de/faq.html">
             http://culfw.de/faq.html</a><br>
       Command reference: <a href="http://culfw.de/commandref.html">
             http://culfw.de/commandref.html</a><br>
-      Google-Group: <a href="http://groups.google.com/group/cul-fans">
-            http://groups.google.com/group/cul-fans</a><br>
+      Forum: <a href="https://forum.fhem.de/index.php/board,6.0.html">
+            FHEM Forum >> CUL >> cul-fans</a><br>
       SVN@sourceforge: <a href="http://culfw.svn.sourceforge.net/viewvc/culfw/trunk/culfw">
             http://culfw.svn.sourceforge.net/viewvc/culfw/trunk/culfw</a><br>
       "Making of" CUL V3: <a href="http://www.youtube.com/watch?v=HsNvnLwz6jQ">
diff -uarN culfw-1.66/version.h culfw-1.67/version.h
--- culfw-1.66/version.h	2015-11-29 20:51:55.000000000 +0100
+++ culfw-1.67/version.h	2017-09-07 15:38:52.000000000 +0200
@@ -1,3 +1,3 @@
 #define VERSION_1               1
-#define VERSION_2               66
-#define VERSION                 "1.66"
+#define VERSION_2               67
+#define VERSION                 "1.67"
